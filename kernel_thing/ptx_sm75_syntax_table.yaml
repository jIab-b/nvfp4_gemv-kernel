metadata:
  generated_on: "2025-12-01"
  generator: "Codex CLI"
  source_tree: "ptx_llm"
  description: "Scaffolded PTX syntax table constrained to instructions validated on GeForce RTX 2060 Super (sm_75, Turing)."
  target_gpu:
    marketing_name: "GeForce RTX 2060 Super"
    architecture: "Turing"
    sm: 75
    compute_capability: "7.5"
    note: "Requester mentioned Ampere, but RTX 2060 Super maps to Turing; table excludes post-sm_75 features (e.g., cp.async, wgmma)."
  ptx_version_span:
    minimum: "6.4"
    recommended: "7.2"
    maximum_tested: "7.8"
  fast_feedback_order:
    - schema_validation
    - ptxas_dryrun
    - smoke_test
    - ncu_profile
  schema_notes:
    - "permutation_axes describe legal suffix/modifier combinations."
    - "rules array encodes guardrails for sm_75."

register_files:
  - name: pred
    decl: ".reg .pred %p<COUNT>;"
    width_bits: 1
  - name: b16
    decl: ".reg .b16 %rs<COUNT>;"
    width_bits: 16
  - name: u32
    decl: ".reg .u32 %r<COUNT>;"
    width_bits: 32
  - name: u64
    decl: ".reg .u64 %rd<COUNT>;"
    width_bits: 64
  - name: f16
    decl: ".reg .f16 %fh<COUNT>;"
    width_bits: 16
  - name: f32
    decl: ".reg .f32 %f<COUNT>;"
    width_bits: 32
  - name: f64
    decl: ".reg .f64 %fd<COUNT>;"
    width_bits: 64

state_spaces:
  - name: global
    qualifier: ".global"
    allows: [ld, st, atom, red]
  - name: shared
    qualifier: ".shared"
    allows: [ld, st, atom, bar.sync]
  - name: local
    qualifier: ".local"
    allows: [ld, st]
  - name: const
    qualifier: ".const"
    allows: [ld]
  - name: param
    qualifier: ".param"
    allows: [ld, st_param]

module_directives:
  - name: .version
    syntax: ".version ${major}.${minor}"
    rules:
      - "Use 6.4-7.8 for sm_75; 7.8 still assembles because PTX back-end maps to compatible SASS."
  - name: .target
    syntax: ".target sm_75{, options}"
    options:
      - "+ptx63"
      - "debug"
    rules:
      - ".target sm_75 ensures ldmatrix and sub-byte mma paths are enabled."
  - name: .address_size
    syntax: ".address_size 64"
    rules:
      - "Turing requires 64-bit addressing for global pointers."
  - name: .entry
    syntax: ".visible .entry ${name}(${param_list})"
    rules:
      - "Each parameter declared with .param (.b64 ptr)."
  - name: .func
    syntax: ".visible .func ${name}(${param_list})"
    rules:
      - "Use for device functions called from kernels."
  - name: .maxnreg
    syntax: ".maxnreg ${n}"
    rules:
      - "Limits registers per thread; supported on all SM >= 20 including sm_75."
      - "Place immediately after .entry/.func declaration."
  - name: .maxntid
    syntax: ".maxntid ${nx}{, ${ny}, ${nz}}"
    rules:
      - "Specifies maximum threads per block; mutually exclusive with .reqntid."
      - "Values must not exceed architectural limits (1024 threads total for sm_75)."
  - name: .reqntid
    syntax: ".reqntid ${nx}{, ${ny}, ${nz}}"
    rules:
      - "Forces exact CTA dimensions (x[,y[,z]])."
      - "Cannot appear alongside .maxntid."
  - name: .minnctapersm
    syntax: ".minnctapersm ${n}"
    rules:
      - "Hints minimum CTAs per SM; requires .maxntid or .reqntid to be present."
  - name: .pragma
    syntax: ".pragma ${key} ${value?}"
    rules:
      - "Common keys on sm_75: \"nounroll\", \"used_bytes_mask\", \"enable_smem_spilling\"."
  - name: .file
    syntax: ".file ${idx} \"${path}\""
    rules:
      - "Declares debug source file for later .loc directives."
  - name: .loc
    syntax: ".loc ${file_idx} ${line} ${col}"
    rules:
      - "Maps subsequent instructions to source locations for debugging/profiling."
  - name: .extern
    syntax: ".extern ${qualifiers} ${symbol};"
    rules:
      - "Used for external function or variable declarations."
  - name: .visible
    syntax: ".visible ${qualifiers} ${symbol}"
    rules:
      - "Marks symbols exported from module; combine with .entry/.func/.global."
  - name: .section
    syntax: ".section ${name}, ${type}"
    rules:
      - "Needed when manual sections (e.g., const data) are declared."

data_directives:
  - name: .global
    syntax: ".global .align ${align} .b8 ${symbol}[${size}] = {${initializer?}};"
    rules:
      - "Alignment must match element width; omit initializer for zeroed storage."
  - name: .const
    syntax: ".const .align ${align} .b8 ${symbol}[${size}] = {${initializer}};"
    rules:
      - "Place read-only tables here; accessed via ld.const."
  - name: .shared
    syntax: ".shared .align ${align} .b8 ${symbol}[${size}];"
    rules:
      - "Counts toward static shared memory usage per block."
  - name: .local
    syntax: ".local .align ${align} .b8 ${symbol}[${size}];"
    rules:
      - "Allocates per-thread stack storage."

instruction_groups:
  - category: control_flow
    instructions:
      - mnemonic: bra
        min_ptx: "1.0"
        min_sm: 10
        summary: "Un/conditional branch with optional .uni modifier."
        templates:
          - syntax: "@${pred}? bra{.uni} ${label};"
            operands:
              - name: pred
                type: pred
                role: guard
              - name: label
                type: label
                role: target
            permutation_axes:
              - axis: uni_flag
                values: ["", ".uni"]
        rules:
          - "Use .uni when all lanes share branch to help reconvergence."
      - mnemonic: ret
        min_ptx: "1.0"
        min_sm: 10
        summary: "Return from .func or .entry (implicit)."
        templates:
          - syntax: "ret;"
            operands: []
        rules:
          - "Not predicable; guard with bra to exit."
      - mnemonic: call
        min_ptx: "1.4"
        min_sm: 20
        summary: "Calls visible .func or .entry."
        templates:
          - syntax: "call.uni (${ret_list}), ${symbol}, (${arg_list});"
            operands:
              - name: ret_list
                type: list(reg)
              - name: symbol
                type: label
              - name: arg_list
                type: list(reg|param)
        rules:
          - "Use call.uni for warp-uniform calls to avoid stack divergence on sm_75."
      - mnemonic: exit
        min_ptx: "1.0"
        min_sm: 10
        summary: "Terminate the calling thread."
        templates:
          - syntax: "exit;"
            operands: []
        rules:
          - "All active lanes execute exit simultaneously to avoid divergence."
      - mnemonic: trap
        min_ptx: "1.0"
        min_sm: 10
        summary: "Trigger exception for debugger or error handling."
        templates:
          - syntax: "trap;"
            operands: []
        rules:
          - "Terminates the CTA; only use for fatal conditions."
      - mnemonic: brkpt
        min_ptx: "1.0"
        min_sm: 10
        summary: "Software breakpoint."
        templates:
          - syntax: "brkpt;"
            operands: []
        rules:
          - "No effect unless debugger is attached."
      - mnemonic: nanosleep
        min_ptx: "6.4"
        min_sm: 70
        summary: "Hint to yield execution for a number of cycles."
        templates:
          - syntax: "nanosleep ${cycles};"
            operands:
              - {name: cycles, type: reg|imm, role: wait_cycles}
        rules:
          - "cycles is a 32-bit value; behavior undefined for zero."
  - category: predicates
    instructions:
      - mnemonic: setp
        min_ptx: "1.0"
        min_sm: 10
        summary: "Compare two operands and write predicate."
        templates:
          - syntax: "setp.${cmp}.${type} %p, ${a}, ${b};"
            operands:
              - {name: p, type: pred, role: dest}
              - {name: a, type: reg|imm, role: src0}
              - {name: b, type: reg|imm, role: src1}
            permutation_axes:
              - axis: cmp
                values: ["eq", "ne", "lt", "le", "gt", "ge"]
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f16", "f32", "f64"]
        rules:
          - "Mixed-type compares require explicit cvt upstream."
      - mnemonic: selp
        min_ptx: "1.0"
        min_sm: 10
        summary: "Select between two registers based on predicate."
        templates:
          - syntax: "selp.${type} ${dst}, ${a}, ${b}, %p;"
            operands:
              - {name: dst, type: reg, role: dest}
              - {name: a, type: reg, role: src_if_true}
              - {name: b, type: reg, role: src_if_false}
              - {name: p, type: pred, role: guard}
            permutation_axes:
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f16", "f32", "f64"]
      - mnemonic: vote.sync
        min_ptx: "6.0"
        min_sm: 70
        summary: "Warp vote returning ballot/all/any results."
        templates:
          - syntax: "vote.sync.${mode}.b32 ${dst}, ${pred}, ${mask};"
            operands:
              - {name: dst, type: b32, role: dest}
              - {name: pred, type: pred, role: guard}
              - {name: mask, type: imm|reg, role: active_mask}
            permutation_axes:
              - axis: mode
                values: ["ballot", "all", "any", "uni"]
        rules:
          - "Use full mask 0xffffffff for 32-lane warps."
      - mnemonic: activemask
        min_ptx: "6.0"
        min_sm: 70
        summary: "Read bitmask of currently active lanes."
        templates:
          - syntax: "activemask.b32 ${dst};"
            operands:
              - {name: dst, type: b32, role: dest}
  - category: data_movement
    instructions:
      - mnemonic: mov
        min_ptx: "1.0"
        min_sm: 10
        summary: "Register-to-register move or special register read."
        templates:
          - syntax: "mov.${type} ${dst}, ${src};"
            operands:
              - {name: dst, type: reg(${type}), role: dest}
              - {name: src, type: reg(${type})|imm|special, role: src}
            permutation_axes:
              - axis: type
                values: ["u16", "u32", "u64", "s32", "s64", "f16", "f32", "f64", "b16", "b32"]
        rules:
          - "Special registers for sm_75: %tid.x, %ntid.x, %ctaid.x, %nctaid.x, %laneid, %warpid, %clock, %globaltimer."
      - mnemonic: cvt
        min_ptx: "1.0"
        min_sm: 10
        summary: "Type conversion with optional rounding."
        templates:
          - syntax: "cvt{.sat}{.rm|.rn|.rz|.rp}.${dst_type}.${src_type} ${dst}, ${src};"
            operands:
              - {name: dst, type: reg(dst_type), role: dest}
              - {name: src, type: reg(src_type)|imm, role: src}
            permutation_axes:
              - axis: dst_type
                values: ["f16", "f32", "f64", "s32", "s64", "u32", "u64"]
              - axis: src_type
                values: ["f16", "f32", "f64", "s16", "s32", "s64", "u16", "u32", "u64"]
              - axis: rounding
                values: ["", ".rn", ".rz", ".rm", ".rp"]
      - mnemonic: ld.global
        min_ptx: "1.0"
        min_sm: 10
        summary: "Load from global memory with cache/scope qualifiers."
        templates:
          - syntax: "ld.global{.cache}{.scope}.{type} ${dst}, [${addr}];"
            operands:
              - {name: dst, type: reg(type)|vector, role: dest}
              - {name: addr, type: reg64|imm, role: address}
            permutation_axes:
              - axis: type
                values: ["u8", "s8", "u16", "s16", "u32", "s32", "u64", "s64", "f16", "f16x2", "f32", "f64", "b16", "b32", "b64", "v2.u32", "v4.u32"]
              - axis: cache
                values: ["", ".ca", ".cg", ".cs", ".lu", ".cv", ".wb", ".L1::evict_last", ".L2::evict_last"]
              - axis: scope
                values: ["", ".relaxed.gpu", ".acquire.gpu", ".release.gpu", ".relaxed.sys", ".acquire.sys", ".release.sys"]
        rules:
          - "Disallow L2::64B, L2::128B, L2::256B, and ::cluster qualifiers on sm_75."
          - "Use 64-bit pointers; align loads for vector widths."
      - mnemonic: st.global
        min_ptx: "1.0"
        min_sm: 10
        summary: "Store to global memory."
        templates:
          - syntax: "st.global{.cache}{.scope}.{type} [${addr}], ${src};"
            operands:
              - {name: addr, type: reg64|imm, role: address}
              - {name: src, type: reg(type)|vector, role: value}
            permutation_axes:
              - axis: type
                values: ["u8", "s8", "u16", "s16", "u32", "s32", "u64", "s64", "f16", "f16x2", "f32", "f64", "b16", "b32", "b64", "v2.u32", "v4.u32"]
              - axis: cache
                values: ["", ".wb", ".cg", ".cs", ".wt", ".L1::evict_last"]
              - axis: scope
                values: ["", ".release.gpu", ".release.sys"]
        rules:
          - "Shared/global scopes symmetric with ld.global; keep same qualifier pairings to avoid mismatched fences."
      - mnemonic: ld.shared
        min_ptx: "1.0"
        min_sm: 10
        summary: "Load from shared memory (CTA scope)."
        templates:
          - syntax: "ld.shared{.relaxed}{.cta}.{type} ${dst}, [${addr}];"
            operands:
              - {name: dst, type: reg(type)|vector, role: dest}
              - {name: addr, type: reg32|reg64, role: address}
            permutation_axes:
              - axis: type
                values: ["u8", "s8", "u16", "s16", "u32", "s32", "u64", "s64", "f16", "f32", "f64", "b16", "b32"]
              - axis: relaxed
                values: ["", ".acquire", ".relaxed"]
        rules:
          - "Addressing is 32-bit for shared memory but codegen often keeps it in 64-bit regs; add cvta.to.shared."
      - mnemonic: st.shared
        min_ptx: "1.0"
        min_sm: 10
        summary: "Store to shared memory."
        templates:
          - syntax: "st.shared{.relaxed}{.cta}.{type} [${addr}], ${src};"
            operands:
              - {name: addr, type: reg32|reg64, role: address}
              - {name: src, type: reg(type)|vector, role: value}
            permutation_axes:
              - axis: type
                values: ["u8", "s8", "u16", "s16", "u32", "s32", "u64", "s64", "f16", "f32", "f64", "b16", "b32"]
              - axis: release
                values: ["", ".release"]
        rules:
          - "sm_75 lacks shared::cluster scope; keep CTA-only."
      - mnemonic: ld.const
        min_ptx: "1.0"
        min_sm: 10
        summary: "Load from constant memory."
        templates:
          - syntax: "ld.const.${type} ${dst}, [${symbol}+${imm?}];"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: symbol, type: const_label, role: base}
            permutation_axes:
              - axis: type
                values: ["b8", "b16", "b32", "b64", "f16", "f32", "f64", "u32", "s32"]
        rules:
          - "Offsets must match element alignment; no cache modifiers allowed."
      - mnemonic: ld.local
        min_ptx: "1.0"
        min_sm: 10
        summary: "Load from per-thread local memory."
        templates:
          - syntax: "ld.local.${type} ${dst}, [${addr}];"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: addr, type: reg64|imm, role: address}
            permutation_axes:
              - axis: type
                values: ["b8", "b16", "b32", "b64", "f16", "f32", "f64", "u32", "s32"]
        rules:
          - "Use cvta.to.local before addressing local pointers larger than 32 bits."
      - mnemonic: st.local
        min_ptx: "1.0"
        min_sm: 10
        summary: "Store to per-thread local memory."
        templates:
          - syntax: "st.local.${type} [${addr}], ${src};"
            operands:
              - {name: addr, type: reg64|imm, role: address}
              - {name: src, type: reg(type), role: value}
            permutation_axes:
              - axis: type
                values: ["b8", "b16", "b32", "b64", "f16", "f32", "f64", "u32", "s32"]
        rules:
          - "Local memory accesses are thread-private and spill to DRAM; keep aligned."
      - mnemonic: ld.param
        min_ptx: "1.0"
        min_sm: 10
        summary: "Load kernel argument or stack slot."
        templates:
          - syntax: "ld.param.${type} ${dst}, [${symbol}+${imm?}];"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: symbol, type: param_label, role: base}
        rules:
          - "Parameter offsets must be 4- or 8-byte aligned."
      - mnemonic: cvta
        min_ptx: "2.0"
        min_sm: 20
        summary: "Convert generic pointers to specific state spaces."
        templates:
          - syntax: "cvta.to.${space}.u64 ${dst}, ${src};"
            operands:
              - {name: dst, type: reg64, role: dest}
              - {name: src, type: reg64, role: src}
            permutation_axes:
              - axis: space
                values: ["global", "shared", "local"]
  - category: arithmetic_and_logic
    instructions:
      - mnemonic: add
        min_ptx: "1.0"
        min_sm: 10
        summary: "Integer or FP addition."
        templates:
          - syntax: "add{.sat}${.type} ${dst}, ${a}, ${b};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type)|imm, role: src0}
              - {name: b, type: reg(type)|imm, role: src1}
            permutation_axes:
              - axis: type
                values: ["s16", "u16", "s32", "u32", "s64", "u64", "f16", "f32", "f64", "f16x2"]
              - axis: sat
                values: ["", ".sat"]
        rules:
          - "Use add.cc/addc for 64-bit carry chains." 
      - mnemonic: mad
        min_ptx: "1.0"
        min_sm: 10
        summary: "Multiply-add (integer)."
        templates:
          - syntax: "mad.lo.${type} ${dst}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type)|imm, role: multiplicand0}
              - {name: b, type: reg(type)|imm, role: multiplicand1}
              - {name: c, type: reg(type)|imm, role: addend}
            permutation_axes:
              - axis: type
                values: ["s32", "u32", "s16", "u16"]
        rules:
          - "Use mad.wide.u32 for address arithmetic -> 64-bit."
      - mnemonic: fma
        min_ptx: "2.0"
        min_sm: 20
        summary: "Fused multiply-add (floating point)."
        templates:
          - syntax: "fma.rn.${type} ${dst}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type), role: multiplicand0}
              - {name: b, type: reg(type), role: multiplicand1}
              - {name: c, type: reg(type), role: addend}
            permutation_axes:
              - axis: type
                values: ["f16", "f32", "f64"]
              - axis: rounding
                values: [".rn", ".rz", ".rm", ".rp"]
      - mnemonic: mul.wide
        min_ptx: "1.0"
        min_sm: 10
        summary: "Widening multiply (e.g., 32x32->64)."
        templates:
          - syntax: "mul.wide.${type} ${dst64}, ${a}, ${b};"
            operands:
              - {name: dst64, type: reg64, role: dest}
              - {name: a, type: reg(type)|imm, role: src0}
              - {name: b, type: reg(type)|imm, role: src1}
            permutation_axes:
              - axis: type
                values: ["s16", "u16", "s32", "u32"]
      - mnemonic: mad.wide
        min_ptx: "1.0"
        min_sm: 10
        summary: "Multiply-add producing 64-bit result."
        templates:
          - syntax: "mad.wide.${type} ${dst64}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst64, type: reg64, role: dest}
              - {name: a, type: reg(type)|imm, role: multiplicand0}
              - {name: b, type: reg(type)|imm, role: multiplicand1}
              - {name: c, type: reg64|imm, role: addend}
            permutation_axes:
              - axis: type
                values: ["s32", "u32"]
      - mnemonic: shl
        min_ptx: "1.0"
        min_sm: 10
        summary: "Shift left logical."
        templates:
          - syntax: "shl.${type} ${dst}, ${a}, ${b};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type), role: src0}
              - {name: b, type: reg(type)|imm, role: shift}
            permutation_axes:
              - axis: type
                values: ["b16", "b32", "b64", "u32", "u64"]
      - mnemonic: shr
        min_ptx: "1.0"
        min_sm: 10
        summary: "Shift right (logical/arithmetic)."
        templates:
          - syntax: "shr.${mode}.${type} ${dst}, ${a}, ${b};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type), role: src0}
              - {name: b, type: reg(type)|imm, role: shift}
            permutation_axes:
              - axis: mode
                values: ["u", "s"]
              - axis: type
                values: ["32", "64", "16"]
      - mnemonic: lop3
        min_ptx: "4.2"
        min_sm: 32
        summary: "3-input boolean LUT (Turing supports)."
        templates:
          - syntax: "lop3.${type} ${dst}, ${a}, ${b}, ${c}, ${imm8};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type), role: src0}
              - {name: b, type: reg(type), role: src1}
              - {name: c, type: reg(type), role: src2}
              - {name: imm8, type: imm8, role: lut}
            permutation_axes:
              - axis: type
                values: ["b32", "b64", "u32"]
        rules:
          - "imm8 encodes boolean truth table; use 0xE4 for (a&b)|(~a&c)."
  - category: synchronization
    instructions:
      - mnemonic: bar.sync
        min_ptx: "1.0"
        min_sm: 10
        summary: "CTA-wide barrier."
        templates:
          - syntax: "bar.sync ${barrier_id};"
            operands:
              - {name: barrier_id, type: imm|reg, role: barrier}
        rules:
          - "sm_75 exposes 16 HW barriers (0-15)."
      - mnemonic: membar
        min_ptx: "1.0"
        min_sm: 10
        summary: "Memory fence by scope."
        templates:
          - syntax: "membar.${scope};"
            operands: []
            permutation_axes:
              - axis: scope
                values: ["cta", "gl", "sys"]
        rules:
          - "Use membar.cta before shared memory releases; gl/sys before global/system pairs."
      - mnemonic: atom.global
        min_ptx: "1.1"
        min_sm: 11
        summary: "Atomic operations in global memory."
        templates:
          - syntax: "atom.global.${op}.${type} ${dst}, [${addr}], ${src};"
            operands:
              - {name: dst, type: reg(type), role: return}
              - {name: addr, type: reg64, role: ptr}
              - {name: src, type: reg(type)|imm, role: value}
            permutation_axes:
              - axis: op
                values: ["add", "inc", "dec", "min", "max", "and", "or", "xor", "exch", "cas"]
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f32", "f64"]
        rules:
          - "Use .sys scope variant for host-visible synchronization; available since sm_70."
      - mnemonic: atom.shared
        min_ptx: "1.1"
        min_sm: 11
        summary: "Atomic operations in shared memory."
        templates:
          - syntax: "atom.shared.${op}.${type} ${dst}, [${addr}], ${src};"
            operands:
              - {name: dst, type: reg(type), role: return}
              - {name: addr, type: reg32|reg64, role: ptr}
              - {name: src, type: reg(type)|imm, role: value}
            permutation_axes:
              - axis: op
                values: ["add", "inc", "dec", "min", "max", "and", "or", "xor", "exch", "cas"]
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f32"]
        rules:
          - "Addresses typically 32-bit in shared space; convert with cvta.to.shared."
      - mnemonic: red.global
        min_ptx: "1.1"
        min_sm: 11
        summary: "Reduction atomics (write only)."
        templates:
          - syntax: "red.global.${op}.${type} [${addr}], ${src};"
            operands:
              - {name: addr, type: reg64, role: ptr}
              - {name: src, type: reg(type)|imm, role: value}
            permutation_axes:
              - axis: op
                values: ["add", "min", "max", "and", "or", "xor"]
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f32"]
      - mnemonic: red.shared
        min_ptx: "1.1"
        min_sm: 11
        summary: "Shared-memory reduction atomics."
        templates:
          - syntax: "red.shared.${op}.${type} [${addr}], ${src};"
            operands:
              - {name: addr, type: reg32|reg64, role: ptr}
              - {name: src, type: reg(type)|imm, role: value}
            permutation_axes:
              - axis: op
                values: ["add", "min", "max", "and", "or", "xor"]
              - axis: type
                values: ["s32", "u32", "s64", "u64", "f32"]
        rules:
          - "Implicitly returns void; use atom.shared if old value needed."
  - category: warp_ops
    instructions:
      - mnemonic: shfl.sync
        min_ptx: "6.0"
        min_sm: 70
        summary: "Volta+ shuffle with explicit mask."
        templates:
          - syntax: "shfl.sync.${mode}.b32 ${dst}, ${src}, ${idx}, ${mask};"
            operands:
              - {name: dst, type: b32, role: dest}
              - {name: src, type: b32, role: value}
              - {name: idx, type: reg|imm, role: index}
              - {name: mask, type: imm, role: active_mask}
            permutation_axes:
              - axis: mode
                values: ["idx", "up", "down", "bfly"]
        rules:
          - "Use full mask 0xffffffff for 32-lane warp on sm_75."
      - mnemonic: ldmatrix
        min_ptx: "6.5"
        min_sm: 75
        summary: "Warp-level load from shared memory into matrix registers for mma.sync."
        templates:
          - syntax: "ldmatrix.sync.aligned.${shape}.${count}{.trans}.shared.${type} {${dst_list}}, [${addr}];"
            operands:
              - {name: dst_list, type: reg_list, role: fragment}
              - {name: addr, type: reg32|reg64, role: smem_pointer}
            permutation_axes:
              - axis: shape
                values: ["m8n8", "m8n8", "m8n8"]
              - axis: count
                values: ["x1", "x2", "x4"]
              - axis: trans
                values: ["", ".trans"]
              - axis: type
                values: ["b16"]
        rules:
          - "sm_75 supports 16-bit element forms only; .b8 variants require sm_80+."
      - mnemonic: bar.warp.sync
        min_ptx: "6.0"
        min_sm: 70
        summary: "Warp-level barrier with mask."
        templates:
          - syntax: "bar.warp.sync ${mask};"
            operands:
              - {name: mask, type: imm|reg, role: active_mask}
        rules:
          - "Use mask=0xffffffff for full warp; ensures convergence before warp ops."
      - mnemonic: mma.sync
        min_ptx: "6.0"
        min_sm: 70
        summary: "Tensor Core matrix multiply-accumulate (warp)."
        templates:
          - syntax: "mma.sync.aligned.${shape}.row.col.${ctype}.${atype}.${btype}.${dtype} {${d}}, {${a}}, {${b}}, {${c}};"
            operands:
              - {name: d, type: reg_list, role: accumulator_out}
              - {name: a, type: reg_list, role: matrix_a}
              - {name: b, type: reg_list, role: matrix_b}
              - {name: c, type: reg_list, role: accumulator_in}
            permutation_axes:
              - axis: shape
                values: ["m16n8k8", "m16n8k16", "m8n8k4"]
              - axis: ctype
                values: ["f16", "f32", "s32"]
              - axis: atype
                values: ["f16", "tf32", "bf16", "s8", "u8"]
              - axis: btype
                values: ["f16", "tf32", "bf16", "s8", "u8"]
              - axis: dtype
                values: ["f16", "f32", "s32"]
        rules:
          - "Sub-byte (u4/s4/b1) forms are legal on sm_75 but require .satfinite when writing s32."
          - "TF32 inputs down-convert automatically when target is sm_80+; on sm_75 they assemble but map to FP16 throughput."
      - mnemonic: wmma.load
        min_ptx: "6.2"
        min_sm: 70
        summary: "Legacy WMMA API wrappers."
        templates:
          - syntax: "wmma.load.${matrix}.${layout}.${type} ${fragment}, [${addr}], ${stride};"
            operands:
              - {name: fragment, type: reg_list, role: fragment}
              - {name: addr, type: reg64, role: base}
              - {name: stride, type: imm|reg, role: stride}
            permutation_axes:
              - axis: matrix
                values: ["a", "b", "c"]
              - axis: layout
                values: ["row", "col"]
              - axis: type
                values: ["f16", "f32", "s8", "u8"]
        rules:
          - "Prefer mma.sync for new kernels; keep wmma entries for compatibility testing."
      - mnemonic: wmma.store
        min_ptx: "6.2"
        min_sm: 70
        summary: "Store WMMA accumulator to memory."
        templates:
          - syntax: "wmma.store.${matrix}.${layout}.${type} [${addr}], ${fragment}, ${stride};"
            operands:
              - {name: addr, type: reg64, role: dst_ptr}
              - {name: fragment, type: reg_list, role: accumulator}
              - {name: stride, type: imm|reg, role: stride}
            permutation_axes:
              - axis: matrix
                values: ["d"]
              - axis: layout
                values: ["row", "col"]
              - axis: type
                values: ["f16", "f32", "s32"]
  - category: misc
    instructions:
      - mnemonic: prmt
        min_ptx: "1.4"
        min_sm: 20
        summary: "Permute bytes/halfwords, often used for fp4 packs."
        templates:
          - syntax: "prmt.${mode}.b32 ${dst}, ${a}, ${b}, ${imm8};"
            operands:
              - {name: dst, type: b32, role: dest}
              - {name: a, type: b32, role: src0}
              - {name: b, type: b32, role: src1}
              - {name: imm8, type: imm8, role: control}
            permutation_axes:
              - axis: mode
                values: ["", "b32"]
        rules:
          - "imm8 selects nibble order; see PTX ISA fig. 44."
      - mnemonic: shf
        min_ptx: "3.2"
        min_sm: 32
        summary: "Funnel shift (shift+insert)."
        templates:
          - syntax: "shf.${mode}.${type} ${dst}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst, type: reg(type), role: dest}
              - {name: a, type: reg(type), role: hi_src}
              - {name: b, type: reg(type), role: lo_src}
              - {name: c, type: reg(type)|imm, role: shift_amount}
            permutation_axes:
              - axis: mode
                values: ["l", "r"]
              - axis: type
                values: ["b32", "b64"]
        rules:
          - "Use for bitfield extraction; .wrap not supported on sm_75."
      - mnemonic: dp4a
        min_ptx: "5.2"
        min_sm: 61
        summary: "4-way dot product accumulate on packed int8."
        templates:
          - syntax: "dp4a.${dst_type}.${a_type}.${b_type} ${dst}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst, type: reg(dst_type), role: dest}
              - {name: a, type: reg(a_type), role: packed_vec4}
              - {name: b, type: reg(b_type), role: packed_vec4}
              - {name: c, type: reg(dst_type), role: accumulator}
            permutation_axes:
              - axis: dst_type
                values: ["s32", "u32"]
              - axis: a_type
                values: ["s32", "u32"]
              - axis: b_type
                values: ["s32", "u32"]
        rules:
          - "Operands hold four packed int8 lanes in 32-bit registers."
      - mnemonic: dp2a
        min_ptx: "5.2"
        min_sm: 61
        summary: "2-way dot product accumulate on packed int16."
        templates:
          - syntax: "dp2a.${dst_type}.${a_type}.${b_type} ${dst}, ${a}, ${b}, ${c};"
            operands:
              - {name: dst, type: reg(dst_type), role: dest}
              - {name: a, type: reg(a_type), role: packed_vec2}
              - {name: b, type: reg(b_type), role: packed_vec2}
              - {name: c, type: reg(dst_type), role: accumulator}
            permutation_axes:
              - axis: dst_type
                values: ["s32", "u32"]
              - axis: a_type
                values: ["s32", "u32"]
              - axis: b_type
                values: ["s32", "u32"]
        rules:
          - "Each operand packs two int16 lanes."

validation_profiles:
  - name: syntax_only
    steps:
      - "Validate YAML entry -> render PTX -> run tokenizer."
  - name: sm75_ptxas
    steps:
      - "ptxas -arch=sm_75 -o /dev/null candidate.ptx"
      - "if success -> unit tests"
  - name: ncu_hotloop
    steps:
      - "Run curated GEMV microbenchmark"
      - "Collect ncu --metrics sm__sass_average_branch_targets_threads_uniform.pct, smsp__sass_average_data_bytes_per_sector_mem_global_op_st.sum"

usage_notes:
  - "Extend instruction_groups as support for additional mnemonics is validated on target hardware."
  - "permutation_axes is intentionally compact; expand to explicit Cartesian products when training data generator needs enumerated strings."
  - "When wrapping LLM helpers, feed them rows of this table to constrain decoding."

kernel_blueprint:
  launch_config:
    block_dim:
      type: "vector3"
      constraints:
        - "Each component multiple of 32 for warp-aligned kernels."
        - "Max (1024 threads / block)."
    grid_dim:
      type: "vector3"
      constraints:
        - "gridDim.x * blockDim.x >= problem M extent"
        - "gridDim.y encodes batch or tile groups"
    shared_mem_bytes:
      type: "int"
      constraints:
        - "<= 48 KB default on Turing unless opt-in to 96 KB."
    stream:
      type: "int"
      constraints:
        - "Optional; default 0."
  parameter_slots:
    - name: "ptr_a"
      decl: ".param .b64 ptr_A"
      usage: "cvta.to.global / ld.param"
    - name: "ptr_b"
      decl: ".param .b64 ptr_B"
    - name: "ptr_c"
      decl: ".param .b64 ptr_C"
    - name: "sizes"
      decl: ".param .b32 size_MN"
      repeatable: true
    rules:
      - "Every .entry must list slots in order; offsets auto-derived."
  memory_declarations:
    shared:
      syntax: ".shared .align ${align} .b8 ${symbol}[${bytes}];"
      notes:
        - "allow symbol reuse for double-buffering"
    const:
      syntax: ".const .align ${align} .b32 ${symbol}[${count}];"
    local:
      syntax: ".local .align ${align} .b8 ${symbol}[${bytes}];"
  phases:
    - name: prologue
      steps:
        - "ld.param to pull kernel args"
        - "cvta.to.global/shared conversions"
        - "mov.u32 %tid.x etc for lane math"
    - name: tile_loop
      steps:
        - "ld.global / ld.shared sequences"
        - "mma.sync / fma pipelines"
        - "bar.sync + pointer updates"
    - name: epilogue
      steps:
        - "optional reduction / normalization"
        - "st.global writes"
        - "ret"
  instrumentation_hooks:
    - name: "debug_barrier"
      snippet: "bar.sync 0;"
      use_cases: "Insert when verifying shared-memory hazards."
    - name: "timer_sample"
      snippet: "mov.u64 %time, %globaltimer;"
      use_cases: "Stamp cycles for reward shaping."
