### 9.7.10. Texture Instructions 

This section describes PTX instructions for accessing textures and samplers. PTX supports the
following operations on texture and sampler descriptors:

* Static initialization of texture and sampler descriptors.
* Module-scope and per-entry scope definitions of texture and sampler descriptors.
* Ability to query fields within texture and sampler descriptors.

#### 9.7.10.1. [Texturing Modes](#texturing-modes)[](#texturing-modes "Permalink to this headline")

For working with textures and samplers, PTX has two modes of operation. In the *unified mode,*
texture and sampler information is accessed through a single `.texref` handle. In the *independent
mode*, texture and sampler information each have their own handle, allowing them to be defined
separately and combined at the site of usage in the program.

The advantage of unified mode is that it allows 256 samplers per kernel (128 for architectures prior
to `sm_3x`), with the restriction that they correspond 1-to-1 with the 256 possible textures per
kernel (128 for architectures prior to `sm_3x`). The advantage of independent mode is that
textures and samplers can be mixed and matched, but the number of samplers is greatly restricted to
32 per kernel (16 for architectures prior to `sm_3x`).

[Table 34](#texturing-modes-textures-samplers-surfaces) summarizes the number of textures, samplers and
surfaces available in different texturing modes.

Table 34 Texture, sampler and surface limits[](#texturing-modes-textures-samplers-surfaces "Permalink to this table")






| Texturing mode | Resource | `sm_1x`, `sm_2x` | `sm_3x+` |
| --- | --- | --- | --- |
| Unified mode | Textures | 128 | 256 |
| Samplers | 128 | 256 |
| Surfaces | 8 | 16 |
| Independent mode | Textures | 128 | 256 |
| Samplers | 16 | 32 |
| Surfaces | 8 | 16 |

The texturing mode is selected using `.target` options `texmode_unified` and
`texmode_independent`. A PTX module may declare only one texturing mode. If no texturing mode is
declared, the module is assumed to use unified mode.

**Example**: calculate an element’s power contribution as element’s power/total number of elements.

```
.target texmode_independent

.global .samplerref tsamp1 = { addr_mode_0 = clamp_to_border,

                               filter_mode = nearest

                             };

...

.entry compute_power

  ( .param .texref tex1 )

{

  txq.width.b32  r6, [tex1]; // get tex1's width

  txq.height.b32 r5, [tex1]; // get tex1's height

  tex.2d.v4.f32.f32  {r1,r2,r3,r4}, [tex1, tsamp1, {f1,f2}];

  mul.u32 r5, r5, r6;

  add.f32 r1, r1, r2;

  add.f32 r3, r3, r4;

  add.f32 r1, r1, r3;

  cvt.f32.u32 r5, r5;

  div.f32 r1, r1, r5;

}
```

#### 9.7.10.2. [Mipmaps](#mipmaps)[](#mipmaps "Permalink to this headline")

A *mipmap* is a sequence of textures, each of which is a progressively lower resolution
representation of the same image. The height and width of each image, or level of detail (LOD), in
the mipmap is a power of two smaller than the previous level. Mipmaps are used in graphics
applications to improve rendering speed and reduce aliasing artifacts. For example, a
high-resolution mipmap image is used for objects that are close to the user; lower-resolution images
are used as the object appears farther away. Mipmap filtering modes are provided when switching
between two levels of detail (LODs) in order to avoid abrupt changes in visual fidelity.

**Example:** If the texture has a basic size of 256 by 256 pixels, then the associated mipmap set
may contain a series of eight images, each one-fourth the total area of the previous one: 128x128
pixels, 64x64, 32x32, 16x16, 8x8, 4x4, 2x2, 1x1 (a single pixel). If, for example, a scene is
rendering this texture in a space of 40x40 pixels, then either a scaled up version of the 32x32
(without trilinear interpolation) or an interpolation of the 64x64 and the 32x32 mipmaps (with
trilinear interpolation) would be used.

The total number of LODs in a complete mipmap pyramid is calculated through the following equation:

```
numLODs = 1 + floor(log2(max(w, h, d)))
```

The finest LOD is called the base level and is the 0th level. The next (coarser) level is the 1st
level, and so on. The coarsest level is the level of size (1 x 1 x 1). Each successively smaller
mipmap level has half the {width, height, depth} of the previous level, but if this half value is a
fractional value, it’s rounded down to the next largest integer. Essentially, the size of a mipmap
level can be specified as:

```
max(1, floor(w_b / 2^i)) x

max(1, floor(h_b / 2^i)) x

max(1, floor(d_b / 2^i))
```

where *i* is the ith level beyond the 0th level (the base level). And *w\_b*, *h\_b* and *d\_b* are the
width, height and depth of the base level respectively.

PTX support for mipmaps

The PTX `tex` instruction supports three modes for specifying the LOD: *base*, *level*, and
*grad*ient. In base mode, the instruction always picks level 0. In level mode, an additional
argument is provided to specify the LOD to fetch from. In gradmode, two floating-point vector
arguments provide *partials* (e.g., `{ds/dx, dt/dx}` and `{ds/dy, dt/dy}` for a 2d texture),
which the `tex` instruction uses to compute the LOD.

These instructions provide access to texture memory.

* `tex`
* `tld4`
* `txq`

#### 9.7.10.3. [Texture Instructions: `tex`](#texture-instructions-tex)[](#texture-instructions-tex "Permalink to this headline")

`tex`

Perform a texture memory lookup.

Syntax

```
tex.geom.v4.dtype.ctype  d, [a, c] {, e} {, f};

tex.geom.v4.dtype.ctype  d[|p], [a, b, c] {, e} {, f};  // explicit sampler



tex.geom.v2.f16x2.ctype  d[|p], [a, c] {, e} {, f};

tex.geom.v2.f16x2.ctype  d[|p], [a, b, c] {, e} {, f};  // explicit sampler



// mipmaps

tex.base.geom.v4.dtype.ctype   d[|p], [a, {b,} c] {, e} {, f};

tex.level.geom.v4.dtype.ctype  d[|p], [a, {b,} c], lod {, e} {, f};

tex.grad.geom.v4.dtype.ctype   d[|p], [a, {b,} c], dPdx, dPdy {, e} {, f};



tex.base.geom.v2.f16x2.ctype   d[|p], [a, {b,} c] {, e} {, f};

tex.level.geom.v2.f16x2.ctype  d[|p], [a, {b,} c], lod {, e} {, f};

tex.grad.geom.v2.f16x2.ctype   d[|p], [a, {b,} c], dPdx, dPdy {, e} {, f};



.geom  = { .1d, .2d, .3d, .a1d, .a2d, .cube, .acube, .2dms, .a2dms };

.dtype = { .u32, .s32, .f16,  .f32 };

.ctype = {       .s32, .f32 };          // .cube, .acube require .f32

                                        // .2dms, .a2dms require .s32
```

Description

`tex.{1d,2d,3d}`

Texture lookup using a texture coordinate vector. The instruction loads data from the texture named
by operand `a` at coordinates given by operand `c` into destination `d`. Operand `c` is a
scalar or singleton tuple for 1d textures; is a two-element vector for 2d textures; and is a
four-element vector for 3d textures, where the fourth element is ignored. An optional texture
sampler `b` may be specified. If no sampler is specified, the sampler behavior is a property of
the named texture. The optional destination predicate `p` is set to `True` if data from texture
at specified coordinates is resident in memory, `False` otherwise. When optional destination
predicate `p` is set to `False`, data loaded will be all zeros. Memory residency of Texture Data
at specified coordinates is dependent on execution environment setup using Driver API calls, prior
to kernel launch. Refer to Driver API documentation for more details including any
system/implementation specific behavior.

An optional operand `e` may be specified. Operand `e` is a vector of `.s32` values that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7. Operand `e` is a singleton tuple for 1d textures; is a two
element vector 2d textures; and is four-element vector for 3d textures, where the fourth element is
ignored.

An optional operand `f` may be specified for `depth textures`. Depth textures are special type
of textures which hold data from the depth buffer. Depth buffer contains depth information of each
pixel. Operand `f` is `.f32` scalar value that specifies depth compare value for depth
textures. Each element fetched from texture is compared against value given in `f` operand. If
comparison passes, result is 1.0; otherwise result is 0.0. These per-element comparison results are
used for the filtering. When using depth compare operand, the elements in texture coordinate vector
`c` have `.f32` type.

Depth compare operand is not supported for `3d` textures.

The instruction returns a two-element vector for destination type `.f16x2`. For all other
destination types, the instruction returns a four-element vector. Coordinates may be given in either
signed 32-bit integer or 32-bit floating point form.

A texture base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.

`tex.{a1d,a2d}`

Texture array selection, followed by texture lookup. The instruction first selects a texture from
the texture array named by operand `a` using the index given by the first element of the array
coordinate vector `c`. The instruction then loads data from the selected texture at coordinates
given by the remaining elements of operand `c` into destination `d`. Operand `c` is a bit-size
type vector or tuple containing an index into the array of textures followed by coordinates within
the selected texture, as follows:

* For 1d texture arrays, operand `c` has type `.v2.b32`. The first element is interpreted as an
  unsigned integer index (`.u32`) into the texture array, and the second element is interpreted as
  a 1d texture coordinate of type `.ctype`.
* For 2d texture arrays, operand `c` has type `.v4.b32`. The first element is interpreted as an
  unsigned integer index (`.u32`) into the texture array, and the next two elements are
  interpreted as 2d texture coordinates of type `.ctype`. The fourth element is ignored.

An optional texture sampler `b` may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.

An optional operand `e` may be specified. Operand `e` is a vector of `.s32` values that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7. Operand `e` is a singleton tuple for 1d texture arrays; and is
a two element vector 2d texture arrays.

An optional operand `f` may be specified for depth textures arrays. Operand `f` is `.f32`
scalar value that specifies depth compare value for depth textures. When using depth compare
operand, the coordinates in texture coordinate vector `c` have `.f32` type.

The instruction returns a two-element vector for destination type `.f16x2`. For all other
destination types, the instruction returns a four-element vector. The texture array index is a
32-bit unsigned integer, and texture coordinate elements are 32-bit signed integer or floating point
values.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

`tex.cube`

*Cubemap* texture lookup. The instruction loads data from the cubemap texture named by operand `a`
at coordinates given by operand `c` into destination `d`. Cubemap textures are special
two-dimensional layered textures consisting of six layers that represent the faces of a cube. All
layers in a cubemap are of the same size and are square (i.e., width equals height).

When accessing a cubemap, the texture coordinate vector `c` has type `.v4.f32`, and comprises
three floating-point coordinates (`s`, `t`, `r`) and a fourth padding argument which is
ignored. Coordinates (`s`, `t`, `r`) are projected onto one of the six cube faces. The (`s`,
`t`, `r`) coordinates can be thought of as a direction vector emanating from the center of the
cube. Of the three coordinates (`s`, `t`, `r`), the coordinate of the largest magnitude (the
major axis) selects the cube face. Then, the other two coordinates (the minor axes) are divided by
the absolute value of the major axis to produce a new (`s`, `t`) coordinate pair to lookup into
the selected cube face.

An optional texture sampler `b` may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.

Offset vector operand `e` is not supported for cubemap textures.

an optional operand `f` may be specified for cubemap depth textures. operand `f` is `.f32`
scalar value that specifies depth compare value for cubemap depth textures.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

`tex.acube`

Cubemap array selection, followed by cubemap lookup. The instruction first selects a cubemap texture
from the cubemap array named by operand `a` using the index given by the first element of the
array coordinate vector `c`. The instruction then loads data from the selected cubemap texture at
coordinates given by the remaining elements of operand `c` into destination `d`.

*Cubemap array* textures consist of an array of cubemaps, i.e., the total number of layers is a
multiple of six. When accessing a cubemap array texture, the coordinate vector `c` has type
`.v4.b32`. The first element is interpreted as an unsigned integer index (`.u32`) into the
cubemap array, and the remaining three elements are interpreted as floating-point cubemap
coordinates (`s`, `t`, `r`), used to lookup in the selected cubemap as described above.

An optional texture sampler `b` may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.

Offset vector operand `e` is not supported for cubemap texture arrays.

An optional operand `f` may be specified for cubemap depth texture arrays. Operand `f` is
`.f32` scalar value that specifies depth compare value for cubemap depth textures.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

`tex.2dms`

Multi-sample texture lookup using a texture coordinate vector. Multi-sample textures consist of
multiple samples per data element. The instruction loads data from the texture named by operand
`a` from sample number given by first element of the operand `c`, at coordinates given by
remaining elements of operand `c` into destination `d`. When accessing a multi-sample texture,
texture coordinate vector `c` has type `.v4.b32`. The first element in operand `c` is
interpreted as unsigned integer sample number (`.u32`), and the next two elements are interpreted
as signed integer (`.s32`) 2d texture coordinates. The fourth element is ignored. An optional
texture sampler `b` may be specified. If no sampler is specified, the sampler behavior is a
property of the named texture.

An optional operand `e` may be specified. Operand `e` is a vector of type `.v2.s32` that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7.

Depth compare operand `f` is not supported for multi-sample textures.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

`tex.a2dms`

Multi-sample texture array selection, followed by multi-sample texture lookup. The instruction first
selects a multi-sample texture from the multi-sample texture array named by operand a using the
index given by the first element of the array coordinate vector `c`. The instruction then loads
data from the selected multi-sample texture from sample number given by second element of the
operand `c`, at coordinates given by remaining elements of operand `c` into destination
`d`. When accessing a multi-sample texture array, texture coordinate vector `c` has type
`.v4.b32`. The first element in operand c is interpreted as unsigned integer sampler number, the
second element is interpreted as unsigned integer index (`.u32`) into the multi-sample texture
array and the next two elements are interpreted as signed integer (`.s32`) 2d texture
coordinates. An optional texture sampler `b` may be specified. If no sampler is specified, the
sampler behavior is a property of the named texture.

An optional operand `e` may be specified. Operand `e` is a vector of type `.v2.s32` values
that specifies coordinate offset. Offset is applied to coordinates before doing texture
lookup. Offset value is in the range of -8 to +7.

Depth compare operand `f` is not supported for multi-sample texture arrays.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

Mipmaps

`.base` (lod zero)
:   Pick level 0 (base level). This is the default if no mipmap mode is specified. No additional arguments.

`.level` (lod explicit)
:   Requires an additional 32-bit scalar argument, `lod`, which contains the LOD to fetch from. The
    type of `lod` follows `.ctype` (either `.s32` or `.f32`). Geometries `.2dms` and
    `.a2dms` are not supported in this mode.

`.grad` (lod gradient)
:   Requires two `.f32` vectors, `dPdx` and `dPdy`, that specify the partials. The vectors are
    singletons for 1d and a1d textures; are two-element vectors for 2d and a2d textures; and are
    four-element vectors for 3d, cube and acube textures, where the fourth element is ignored for 3d
    and cube geometries. Geometries `.2dms` and `.a2dms` are not supported in this mode.

For mipmap texture lookup, an optional operand `e` may be specified. Operand `e` is a vector of
`.s32` that specifies coordinate offset. Offset is applied to coordinates before doing texture
lookup. Offset value is in the range of -8 to +7. Offset vector operand is not supported for cube
and cubemap geometries.

An optional operand `f` may be specified for mipmap textures. Operand `f` is `.f32` scalar
value that specifies depth compare value for depth textures. When using depth compare operand, the
coordinates in texture coordinate vector `c` have `.f32` type.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

Depth compare operand is not supported for `3d` textures.

Indirect texture access

Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture `sm_20` or higher. In indirect access, operand `a` is a `.u64` register holding
the address of a `.texref` variable.

Notes

For compatibility with prior versions of PTX, the square brackets are not required and `.v4`
coordinate vectors are allowed for any geometry, with the extra elements being ignored.

PTX ISA Notes

Unified mode texturing introduced in PTX ISA version 1.0. Extension using opaque `.texref` and
`.samplerref` types and independent mode texturing introduced in PTX ISA version 1.5.

Texture arrays `tex.{a1d,a2d}` introduced in PTX ISA version 2.3.

Cubemaps and cubemap arrays introduced in PTX ISA version 3.0.

Support for mipmaps introduced in PTX ISA version 3.1.

Indirect texture access introduced in PTX ISA version 3.1.

Multi-sample textures and multi-sample texture arrays introduced in PTX ISA version 3.2.

Support for textures returning `.f16` and `.f16x2` data introduced in PTX ISA version 4.2.

Support for `tex.grad.{cube, acube}` introduced in PTX ISA version 4.3.

Offset vector operand introduced in PTX ISA version 4.3.

Depth compare operand introduced in PTX ISA version 4.3.

Support for optional destination predicate introduced in PTX ISA version 7.1.

Target ISA Notes

Supported on all target architectures.

The cubemap array geometry (`.acube`) requires `sm_20` or higher.

Mipmaps require `sm_20` or higher.

Indirect texture access requires `sm_20` or higher.

Multi-sample textures and multi-sample texture arrays require `sm_30` or higher.

Texture fetch returning `.f16` and `.f16x2` data require `sm_53` or higher.

`tex.grad.{cube, acube}` requires `sm_20` or higher.

Offset vector operand requires `sm_30` or higher.

Depth compare operand requires `sm_30` or higher.

Support for optional destination predicate requires `sm_60` or higher.

Examples

```
 // Example of unified mode texturing

 // - f4 is required to pad four-element tuple and is ignored

 tex.3d.v4.s32.s32  {r1,r2,r3,r4}, [tex_a,{f1,f2,f3,f4}];



 // Example of independent mode texturing

 tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,smpl_x,{f1}];



 // Example of 1D texture array, independent texturing mode

 tex.a1d.v4.s32.s32 {r1,r2,r3,r4}, [tex_a,smpl_x,{idx,s1}];



 // Example of 2D texture array, unified texturing mode

 // - f3 is required to pad four-element tuple and is ignored

 tex.a2d.v4.s32.f32 {r1,r2,r3,r4}, [tex_a,{idx,f1,f2,f3}];



 // Example of cubemap array, unified textureing mode

 tex.acube.v4.f32.f32 {r0,r1,r2,r3}, [tex_cuarray,{idx,f1,f2,f3}];



 // Example of multi-sample texture, unified texturing mode

 tex.2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ms,{sample,r6,r7,r8}];



 // Example of multi-sample texture, independent texturing mode

 tex.2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ms, smpl_x,{sample,r6,r7,r8}];



 // Example of multi-sample texture array, unified texturing mode

 tex.a2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ams,{idx,sample,r6,r7}];



 // Example of texture returning .f16 data

 tex.1d.v4.f16.f32  {h1,h2,h3,h4}, [tex_a,smpl_x,{f1}];



 // Example of texture returning .f16x2 data

 tex.1d.v2.f16x2.f32  {h1,h2}, [tex_a,smpl_x,{f1}];



 // Example of 3d texture array access with tex.grad,unified texturing mode

 tex.grad.3d.v4.f32.f32 {%f4,%f5,%f6,%f7},[tex_3d,{%f0,%f0,%f0,%f0}],

                 {fl0,fl1,fl2,fl3},{fl0,fl1,fl2,fl3};



// Example of cube texture array access with tex.grad,unified texturing mode

 tex.grad.cube.v4.f32.f32{%f4,%f5,%f6,%f7},[tex_cube,{%f0,%f0,%f0,%f0}],

                 {fl0,fl1,fl2,fl3},{fl0,fl1,fl2,fl3};



 // Example of 1d texture lookup with offset, unified texturing mode

 tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a, {f1}], {r5};



 // Example of 2d texture array lookup with offset, unified texturing mode

 tex.a2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{idx,f1,f2}], {f5,f6};



 // Example of 2d mipmap texture lookup with offset, unified texturing mode

 tex.level.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}],

                          flvl, {r7, r8};



 // Example of 2d depth texture lookup with compare, unified texturing mode

 tex.1d.v4.f32.f32  {f1,f2,f3,f4}, [tex_a, {f1}], f0;



 // Example of depth 2d texture array lookup with offset, compare

 tex.a2d.v4.s32.f32  {f0,f1,f2,f3}, [tex_a,{idx,f4,f5}], {r5,r6}, f6;



 // Example of destination predicate use

 tex.3d.v4.s32.s32 {r1,r2,r3,r4}|p, [tex_a,{f1,f2,f3,f4}];
```

#### 9.7.10.4. [Texture Instructions: `tld4`](#texture-instructions-tld4)[](#texture-instructions-tld4 "Permalink to this headline")

`tld4`

Perform a texture fetch of the 4-texel bilerp footprint.

Syntax

```
tld4.comp.2d.v4.dtype.f32    d[|p], [a, c] {, e} {, f};

tld4.comp.geom.v4.dtype.f32  d[|p], [a, b, c] {, e} {, f};  // explicit sampler



.comp  = { .r, .g, .b, .a };

.geom  = { .2d, .a2d, .cube, .acube };

.dtype = { .u32, .s32, .f32 };
```

Description

Texture fetch of the 4-texel bilerp footprint using a texture coordinate vector. The instruction
loads the bilerp footprint from the texture named by operand `a` at coordinates given by operand
`c` into vector destination `d`. The texture component fetched for each texel sample is
specified by `.comp`. The four texel samples are placed into destination vector `d` in
counter-clockwise order starting at lower left.

An optional texture sampler `b` may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.

The optional destination predicate `p` is set to `True` if data from texture at specified
coordinates is resident in memory, `False` otherwise. When optional destination predicate `p` is
set to `False`, data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.

An optional operand `f` may be specified for *depth textures*. Depth textures are special type of
textures which hold data from the depth buffer. Depth buffer contains depth information of each
pixel. Operand `f` is `.f32` scalar value that specifies depth compare value for depth
textures. Each element fetched from texture is compared against value given in `f` operand. If
comparison passes, result is 1.0; otherwise result is 0.0. These per-element comparison results are
used for the filtering.

A texture base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.

`tld4.2d`

For 2D textures, operand `c` specifies coordinates as a two-element, 32-bit floating-point vector.

An optional operand `e` may be specified. Operand `e` is a vector of type `.v2.s32` that
specifies coordinate offset. Offset is applied to coordinates before doing texture fetch. Offset
value is in the range of -8 to +7.

`tld4.a2d`

Texture array selection, followed by `tld4` texture fetch of 2d texture. For 2d texture arrays
operand `c` is a four element, 32-bit vector. The first element in operand c is interpreted as an
unsigned integer index (`.u32`) into the texture array, and the next two elements are interpreted
as 32-bit floating point coordinates of 2d texture. The fourth element is ignored.

An optional operand `e` may be specified. Operand `e` is a vector of type `.v2.s32` that
specifies coordinate offset. Offset is applied to coordinates before doing texture fetch. Offset
value is in the range of -8 to +7.

`tld4.cube`

For cubemap textures, operand `c` specifies four-element vector which comprises three
floating-point coordinates (s, t, r) and a fourth padding argument which is ignored.

Cubemap textures are special two-dimensional layered textures consisting of six layers that
represent the faces of a cube. All layers in a cubemap are of the same size and are square (i.e.,
width equals height).

Coordinates (s, t, r) are projected onto one of the six cube faces. The (s, t, r) coordinates can be
thought of as a direction vector emanating from the center of the cube. Of the three coordinates (s,
t, r), the coordinate of the largest magnitude (the major axis) selects the cube face. Then, the
other two coordinates (the minor axes) are divided by the absolute value of the major axis to
produce a new (s, t) coordinate pair to lookup into the selected cube face.

Offset vector operand `e` is not supported for cubemap textures.

`tld4.acube`

Cubemap array selection, followed by `tld4` texture fetch of cubemap texture. The first element in
operand `c` is interpreted as an unsigned integer index (`.u32`) into the cubemap texture array,
and the remaining three elements are interpreted as floating-point cubemap coordinates (s, t, r),
used to lookup in the selected cubemap.

Offset vector operand `e` is not supported for cubemap texture arrays.

Indirect texture access

Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture `sm_20` or higher. In indirect access, operand `a` is a `.u64` register holding
the address of a `.texref` variable.

PTX ISA Notes

Introduced in PTX ISA version 2.2.

Indirect texture access introduced in PTX ISA version 3.1.

`tld4.{a2d,cube,acube}` introduced in PTX ISA version 4.3.

Offset vector operand introduced in PTX ISA version 4.3.

Depth compare operand introduced in PTX ISA version 4.3.

Support for optional destination predicate introduced in PTX ISA version 7.1.

Target ISA Notes

`tld4` requires `sm_20` or higher.

Indirect texture access requires `sm_20` or higher.

`tld4.{a2d,cube,acube}` requires `sm_30` or higher.

Offset vector operand requires `sm_30` or higher.

Depth compare operand requires `sm_30` or higher.

Support for optional destination predicate requires `sm_60` or higher.

Examples

```
//Example of unified mode texturing

tld4.r.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}];



// Example of independent mode texturing

tld4.r.2d.v4.u32.f32  {u1,u2,u3,u4}, [tex_a,smpl_x,{f1,f2}];



// Example of unified mode texturing using offset

tld4.r.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}], {r5, r6};



// Example of unified mode texturing using compare

tld4.r.2d.v4.f32.f32  {f1,f2,f3,f4}, [tex_a,{f5,f6}], f7;



// Example of optional destination predicate

tld4.r.2d.v4.f32.f32 {f1,f2,f3,f4}|p, [tex_a,{f5,f6}], f7;
```

#### 9.7.10.5. [Texture Instructions: `txq`](#texture-instructions-txq)[](#texture-instructions-txq "Permalink to this headline")

`txq`

Query texture and sampler attributes.

Syntax

```
txq.tquery.b32         d, [a];       // texture attributes

txq.level.tlquery.b32  d, [a], lod;  // texture attributes

txq.squery.b32         d, [a];       // sampler attributes



.tquery  = { .width, .height, .depth,

             .channel_data_type, .channel_order,

             .normalized_coords, .array_size,

             .num_mipmap_levels, .num_samples};



.tlquery = { .width, .height, .depth };



.squery  = { .force_unnormalized_coords, .filter_mode,

             .addr_mode_0, addr_mode_1, addr_mode_2 };
```

Description

Query an attribute of a texture or sampler. Operand `a` is either a `.texref` or `.samplerref` variable, or a `.u64` register.

| Query | Returns |
| --- | --- |
| `.width`  `.height`  `.depth` | value in elements |
| `.channel_data_type` | Unsigned integer corresponding to source language’s channel data type enumeration. If the source language combines channel data type and channel order into a single enumeration type, that value is returned for both `channel_data_type` and channel\_order queries. |
| `.channel_order` | Unsigned integer corresponding to source language’s channel order enumeration. If the source language combines channel data type and channel order into a single enumeration type, that value is returned for both `channel_data_type` and `channel_order` queries. |
| `.normalized_coords` | `1` (`True`) or `0` (`False`). |
| `.force_unnormalized_coords` | `1` (`True)` or `0` (`False).` Defined only for `.samplerref` variables in independent texture mode. Overrides the `normalized_coords` field of a `.texref` variable used with a `.samplerref` in a `tex` instruction. |
| `.filter_mode` | Integer from `enum { nearest, linear }` |
| `.addr_mode_0`  `.addr_mode_1`  `.addr_mode_2` | Integer from `enum { wrap, mirror, clamp_ogl, clamp_to_edge, clamp_to_border }` |
| `.array_size` | For a texture array, number of textures in array, 0 otherwise. |
| `.num_mipmap_levels` | For a mipmapped texture, number of levels of details (LOD), 0 otherwise. |
| `.num_samples` | For a multi-sample texture, number of samples, 0 otherwise. |

Texture attributes are queried by supplying a `.texref` argument to `txq`. In unified mode,
sampler attributes are also accessed via a `.texref` argument, and in independent mode sampler
attributes are accessed via a separate `.samplerref` argument.

`txq.level`

`txq.level` requires an additional 32bit integer argument, `lod`, which specifies LOD and
queries requested attribute for the specified LOD.

Indirect texture access

Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture `sm_20` or higher. In indirect access, operand `a` is a `.u64` register holding
the address of a `.texref` variable.

PTX ISA Notes

Introduced in PTX ISA version 1.5.

Channel data type and channel order queries were added in PTX ISA version 2.1.

The `.force_unnormalized_coords` query was added in PTX ISA version 2.2.

Indirect texture access introduced in PTX ISA version 3.1.

`.array_size`, `.num_mipmap_levels`, `.num_samples` samples queries were added in PTX ISA
version 4.1.

`txq.level` introduced in PTX ISA version 4.3.

Target ISA Notes

Supported on all target architectures.

Indirect texture access requires `sm_20` or higher.

Querying the number of mipmap levels requires `sm_20` or higher.

Querying the number of samples requires `sm_30` or higher.

`txq.level` requires `sm_30` or higher.

Examples

```
txq.width.b32       %r1, [tex_A];

txq.filter_mode.b32 %r1, [tex_A];   // unified mode

txq.addr_mode_0.b32 %r1, [smpl_B];  // independent mode

txq.level.width.b32 %r1, [tex_A], %r_lod;
```

#### 9.7.10.6. [Texture Instructions: `istypep`](#texture-instructions-istypep)[](#texture-instructions-istypep "Permalink to this headline")

`istypep`

Query whether a register points to an opaque variable of a specified type.

Syntax

```
istypep.type   p, a;  // result is .pred



.type = { .texref, .samplerref, .surfref };
```

Description

Write predicate register `p` with 1 if register `a` points to an opaque variable of the
specified type, and with 0 otherwise. Destination `p` has type `.pred`; the source address
operand must be of type `.u64`.

PTX ISA Notes

Introduced in PTX ISA version 4.0.

Target ISA Notes

istypep requires `sm_30` or higher.

Examples

```
istypep.texref istex, tptr;

istypep.samplerref issampler, sptr;

istypep.surfref issurface, surfptr;
```