## 5.2. Types 

### 5.2.1. [Fundamental Types](#fundamental-types)[](#fundamental-types "Permalink to this headline")

In PTX, the fundamental types reflect the native data types supported by the target architectures. A
fundamental type specifies both a basic type and a size. Register variables are always of a
fundamental type, and instructions operate on these types. The same type-size specifiers are used
for both variable definitions and for typing instructions, so their names are intentionally short.

[Table 8](#fundamental-types-fundamental-type-specifiers) lists the fundamental type specifiers for
each basic type:

Table 8 Fundamental Type Specifiers[](#fundamental-types-fundamental-type-specifiers "Permalink to this table")




| Basic Type | Fundamental Type Specifiers |
| --- | --- |
| Signed integer | `.s8`, `.s16`, `.s32`, `.s64` |
| Unsigned integer | `.u8`, `.u16`, `.u32`, `.u64` |
| Floating-point | `.f16`, `.f16x2`, `.f32`, `.f64` |
| Bits (untyped) | `.b8`, `.b16`, `.b32`, `.b64`, `.b128` |
| Predicate | `.pred` |

Most instructions have one or more type specifiers, needed to fully specify instruction
behavior. Operand types and sizes are checked against instruction types for compatibility.

Two fundamental types are compatible if they have the same basic type and are the same size. Signed
and unsigned integer types are compatible if they have the same size. The bit-size type is
compatible with any fundamental type having the same size.

In principle, all variables (aside from predicates) could be declared using only bit-size types, but
typed variables enhance program readability and allow for better operand type checking.

### 5.2.2. [Restricted Use of Sub-Word Sizes](#restricted-use-of-sub-word-sizes)[](#restricted-use-of-sub-word-sizes "Permalink to this headline")

The `.u8`, `.s8`, and `.b8` instruction types are restricted to `ld`, `st`, and `cvt`
instructions. The `.f16` floating-point type is allowed only in conversions to and from `.f32`,
`.f64` types, in half precision floating point instructions and texture fetch instructions. The
`.f16x2` floating point type is allowed only in half precision floating point arithmetic
instructions and texture fetch instructions.

For convenience, `ld`, `st`, and `cvt` instructions permit source and destination data
operands to be wider than the instruction-type size, so that narrow values may be loaded, stored,
and converted using regular-width registers. For example, 8-bit or 16-bit values may be held
directly in 32-bit or 64-bit registers when being loaded, stored, or converted to other types and
sizes.

### 5.2.3. [Alternate Floating-Point Data Formats](#alternate-floating-point-data-formats)[](#alternate-floating-point-data-formats "Permalink to this headline")

The fundamental floating-point types supported in PTX have implicit bit representations that
indicate the number of bits used to store exponent and mantissa. For example, the `.f16` type
indicates 5 bits reserved for exponent and 10 bits reserved for mantissa. In addition to the
floating-point representations assumed by the fundamental types, PTX allows the following alternate
floating-point data formats:

`bf16` data format:
:   This data format is a 16-bit floating point format with 8 bits for exponent and 7 bits for
    mantissa. A register variable containing `bf16` data must be declared with `.b16` type.

`e4m3` data format:
:   This data format is an 8-bit floating point format with 4 bits for exponent and 3 bits for
    mantissa. The `e4m3` encoding does not support infinity and `NaN` values are limited to
    `0x7f` and `0xff`. A register variable containing `e4m3` value must be declared using
    bit-size type.

`e5m2` data format:
:   This data format is an 8-bit floating point format with 5 bits for exponent and 2 bits for
    mantissa. A register variable containing `e5m2` value must be declared using bit-size type.

`tf32` data format:
:   This data format is a special 32-bit floating point format supported by the matrix
    multiply-and-accumulate instructions, with the same range as `.f32` and reduced precision (>=10
    bits). The internal layout of `tf32` format is implementation defined. PTX facilitates
    conversion from single precision `.f32` type to `tf32` format. A register variable containing
    `tf32` data must be declared with `.b32` type.

`e2m1` data format:
:   This data format is a 4-bit floating point format with 2 bits for exponent and 1 bit for mantissa.
    The `e2m1` encoding does not support infinity and `NaN`. `e2m1` values must be used in a
    packed format specified as `e2m1x2`. A register variable containing two `e2m1` values must be
    declared with `.b8` type.

`e2m3` data format:
:   This data format is a 6-bit floating point format with 2 bits for exponent and 3 bits for mantissa.
    The `e2m3` encoding does not support infinity and `NaN`. `e2m3` values must be used in a
    packed format specified as `e2m3x2`. A register variable containing two `e2m3` values must be
    declared with `.b16` type where each `.b8` element has 6-bit floating point value and 2 MSB
    bits padded with zeros.

`e3m2` data format:
:   This data format is a 6-bit floating point format with 3 bits for exponent and 2 bits for mantissa.
    The `e3m2` encoding does not support infinity and `NaN`. `e3m2` values must be used in a
    packed format specified as `e3m2x2`. A register variable containing two `e3m2` values must be
    declared with `.b16` type where each `.b8` element has 6-bit floating point value and 2 MSB
    bits padded with zeros.

`ue8m0` data format:
:   This data format is an 8-bit unsigned floating-point format with 8 bits for exponent and 0 bits for
    mantissa. The `ue8m0` encoding does not support infinity. `NaN` value is limited to `0xff`.
    `ue8m0` values must be used in a packed format specified as `ue8m0x2`. A register variable
    containing two `ue8m0` values must be declared with `.b16` type.

`ue4m3` data format:
:   This data format is a 7-bit unsigned floating-point format with 4 bits for exponent and 3 bits for
    mantissa. The `ue4m3` encoding does not support infinity. `NaN` value is limited to `0x7f`.
    A register variable containing single `ue4m3` value must be declared with `.b8` type having
    MSB bit padded with zero.

Alternate data formats cannot be used as fundamental types. They are supported as source or
destination formats by certain instructions.

### 5.2.4. [Packed Data Types](#packed-data-types)[](#packed-data-types "Permalink to this headline")

Certain PTX instructions operate on two or more sets of inputs in parallel, and produce two or more
outputs. Such instructions can use the data stored in a packed format. PTX supports packing two or
four values of the same scalar data type into a single, larger value. The packed value is considered
as a value of a *packed data type*. In this section we describe the packed data types supported in PTX.

#### 5.2.4.1. [Packed Floating Point Data Types](#packed-floating-point-data-types)[](#packed-floating-point-data-types "Permalink to this headline")

PTX supports various variants of packed floating point data types. Out of them, only `.f16x2` is
supported as a fundamental type, while others cannot be used as fundamental types - they are
supported as instruction types on certain instructions. When using an instruction with such
non-fundamental types, the operand data variables must be of bit type of appropriate size.
For example, all of the operand variables must be of type `.b32` for an instruction with
instruction type as `.bf16x2`.
[Table 9](#operand-types-for-packed-floating-point-instruction-type) described various variants
of packed floating point data types in PTX.

Table 9 Operand types for packed floating point instruction type.[](#operand-types-for-packed-floating-point-instruction-type "Permalink to this table")






| Packed floating point type | Number of elements contained in a packed format | Type of each element | Register variable type to be used in the declaration |
| --- | --- | --- | --- |
| `.f16x2` | Two | `.f16` | `.f16x2` or `.b32` |
| `.f32x2` | `.f32` | `.b64` |
| `.bf16x2` | `.bf16` | `.b32` |
| `.e4m3x2` | `.e4m3` | `.b16` |
| `.e5m2x2` | `.e5m2` |
| `.e2m3x2` | `.e2m3` |
| `.e3m2x2` | `.e3m2` |
| `.ue8m0x2` | `.ue8m0` |
| `.e2m1x2` | `.e2m1` | `.b8` |
| `.e4m3x4` | Four | `.e4m3` | `.b32` |
| `.e5m2x4` | `.e5m2` |
| `.e2m3x4` | `.e2m3` |
| `.e3m2x4` | `.e3m2` |
| `.e2m1x4` | `.e2m1` |

#### 5.2.4.2. [Packed Integer Data Types](#packed-integer-data-types)[](#packed-integer-data-types "Permalink to this headline")

PTX supports two variants of packed integer data types: `.u16x2` and `.s16x2`. The packed data
type consists of two `.u16` or `.s16` values. A register variable containing `.u16x2` or
`.s16x2` data must be declared with `.b32` type. Packed integer data types cannot be used as
fundamental types. They are supported as instruction types on certain instructions.