### 9.7.18. Video Instructions 

All video instructions operate on 32-bit register operands. However, the video instructions may be
classified as either scalar or SIMD based on whether their core operation applies to one or multiple
values.

The video instructions are:

* `vadd`, `vadd2`, `vadd4`
* `vsub`, `vsub2`, `vsub4`
* `vmad`
* `vavrg2`, `vavrg4`
* `vabsdiff`, `vabsdiff2`, `vabsdiff4`
* `vmin`, `vmin2`, `vmin4`
* `vmax`, `vmax2`, `vmax4`
* `vshl`
* `vshr`
* `vset`, `vset2`, `vset4`

#### 9.7.18.1. [Scalar Video Instructions](#scalar-video-instructions)[](#scalar-video-instructions "Permalink to this headline")

All scalar video instructions operate on 32-bit register operands. The scalar video instructions
are:

* `vadd`
* `vsub`
* `vabsdiff`
* `vmin`
* `vmax`
* `vshl`
* `vshr`
* `vmad`
* `vset`

The scalar video instructions execute the following stages:

1. Extract and sign- or zero-extend byte, half-word, or word values from its source operands, to
   produce signed 33-bit input values.
2. Perform a scalar arithmetic operation to produce a signed 34-bit result.
3. Optionally clamp the result to the range of the destination type.
4. Optionally perform one of the following:

   * apply a second operation to the intermediate result and a third operand, or
   * truncate the intermediate result to a byte or half-word value and merge into a specified
     position in the third operand to produce the final result.

The general format of scalar video instructions is as follows:

```
// 32-bit scalar operation, with optional secondary operation

vop.dtype.atype.btype{.sat}        d, a{.asel}, b{.bsel};

vop.dtype.atype.btype{.sat}.secop  d, a{.asel}, b{.bsel}, c;



// 32-bit scalar operation, with optional data merge

vop.dtype.atype.btype{.sat}   d.dsel, a{.asel}, b{.bsel}, c;





.dtype = .atype = .btype = { .u32, .s32 };

.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };

.secop = { .add, .min, .max };
```

The source and destination operands are all 32-bit registers. The type of each operand (`.u32` or
`.s32`) is specified in the instruction type; all combinations of `dtype`, `atype`, and
`btype` are valid. Using the `atype/btype` and `asel/bsel` specifiers, the input values are
extracted and sign- or zero-extended internally to `.s33` values. The primary operation is then
performed to produce an `.s34` intermediate result. The sign of the intermediate result depends on
dtype.

The intermediate result is optionally clamped to the range of the destination type (signed or
unsigned), taking into account the subword destination size in the case of optional data merging.

```
.s33 optSaturate( .s34 tmp, Bool sat, Bool sign, Modifier dsel ) {

    if ( !sat )  return tmp;



    switch ( dsel ) {

        case .b0, .b1, .b2, .b3:

            if ( sign )  return CLAMP( tmp, S8_MAX, S8_MIN );

            else         return CLAMP( tmp, U8_MAX, U8_MIN );

        case .h0, .h1:

            if ( sign )  return CLAMP( tmp, S16_MAX, S16_MIN );

            else         return CLAMP( tmp, U16_MAX, U16_MIN );

        default:

            if ( sign )  return CLAMP( tmp, S32_MAX, S32_MIN );

            else         return CLAMP( tmp, U32_MAX, U32_MIN );

    }

}
```

This intermediate result is then optionally combined with the third source operand using a secondary
arithmetic operation or subword data merge, as shown in the following pseudocode. The sign of the
third operand is based on `dtype`.

```
.s33 optSecOp(Modifier secop, .s33 tmp, .s33 c) {

    switch ( secop ) {

        .add:     return tmp + c;

        .min:     return MIN(tmp, c);

        .max      return MAX(tmp, c);

        default:  return tmp;

    }

}
```

```
.s33 optMerge( Modifier dsel, .s33 tmp, .s33 c ) {

    switch ( dsel ) {

        case .h0:  return ((tmp & 0xffff)        | (0xffff0000 & c);

        case .h1:  return ((tmp & 0xffff) << 16) | (0x0000ffff & c);

        case .b0:  return ((tmp & 0xff)          | (0xffffff00 & c);

        case .b1:  return ((tmp & 0xff) <<  8)   | (0xffff00ff & c);

        case .b2:  return ((tmp & 0xff) << 16)   | (0xff00ffff & c);

        case .b3:  return ((tmp & 0xff) << 24)   | (0x00ffffff & c);

        default:   return tmp;

    }

}
```

The lower 32-bits are then written to the destination operand.

##### 9.7.18.1.1. [Scalar Video Instructions: `vadd`, `vsub`, `vabsdiff`, `vmin`, `vmax`](#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax)[](#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax "Permalink to this headline")

`vadd`, `vsub`

Integer byte/half-word/word addition/subtraction.

`vabsdiff`

Integer byte/half-word/word absolute value of difference.

`vmin`, `vmax`

Integer byte/half-word/word minimum/maximum.

Syntax

```
// 32-bit scalar operation, with optional secondary operation

vop.dtype.atype.btype{.sat}       d, a{.asel}, b{.bsel};

vop.dtype.atype.btype{.sat}.op2   d, a{.asel}, b{.bsel}, c;



// 32-bit scalar operation, with optional data merge

vop.dtype.atype.btype{.sat}  d.dsel, a{.asel}, b{.bsel}, c;



 vop   = { vadd, vsub, vabsdiff, vmin, vmax };

.dtype = .atype = .btype = { .u32, .s32 };

.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };

.op2   = { .add, .min, .max };
```

Description

Perform scalar arithmetic operation with optional saturate, and optional secondary arithmetic operation or subword data merge.

Semantics

```
// extract byte/half-word/word and sign- or zero-extend

// based on source operand type

ta = partSelectSignExtend( a, atype, asel );

tb = partSelectSignExtend( b, btype, bsel );



switch ( vop ) {

    case vadd:     tmp = ta + tb;

    case vsub:     tmp = ta - tb;

    case vabsdiff: tmp = | ta - tb |;

    case vmin:     tmp = MIN( ta, tb );

    case vmax:     tmp = MAX( ta, tb );

}

// saturate, taking into account destination type and merge operations

tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );

d = optSecondaryOp( op2, tmp, c );  // optional secondary operation

d = optMerge( dsel, tmp, c );       // optional merge with c operand
```

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vadd`, `vsub`, `vabsdiff`, `vmin`, `vmax` require `sm_20` or higher.

Examples

```
vadd.s32.u32.s32.sat      r1, r2.b0, r3.h0;

vsub.s32.s32.u32.sat      r1, r2.h1, r3.h1;

vabsdiff.s32.s32.s32.sat  r1.h0, r2.b0, r3.b2, c;

vmin.s32.s32.s32.sat.add  r1, r2, r3, c;
```

##### 9.7.18.1.2. [Scalar Video Instructions: `vshl`, `vshr`](#scalar-video-instructions-vshl-vshr)[](#scalar-video-instructions-vshl-vshr "Permalink to this headline")

`vshl`, `vshr`

Integer byte/half-word/word left/right shift.

Syntax

```
// 32-bit scalar operation, with optional secondary operation

vop.dtype.atype.u32{.sat}.mode       d, a{.asel}, b{.bsel};

vop.dtype.atype.u32{.sat}.mode.op2   d, a{.asel}, b{.bsel}, c;



// 32-bit scalar operation, with optional data merge

vop.dtype.atype.u32{.sat}.mode  d.dsel, a{.asel}, b{.bsel}, c;



 vop   = { vshl, vshr };

.dtype = .atype = { .u32, .s32 };

.mode  = { .clamp, .wrap };

.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };

.op2   = { .add, .min, .max };
```

Description

`vshl`
:   Shift `a` left by unsigned amount in `b` with optional saturate, and optional secondary
    arithmetic operation or subword data merge. Left shift fills with zero.

`vshr`
:   Shift `a` right by unsigned amount in `b` with optional saturate, and optional secondary
    arithmetic operation or subword data merge. Signed shift fills with the sign bit, unsigned shift
    fills with zero.

Semantics

```
// extract byte/half-word/word and sign- or zero-extend

// based on source operand type

ta = partSelectSignExtend( a,atype, asel );

tb = partSelectSignExtend( b, .u32, bsel );

if ( mode == .clamp  && tb > 32 )  tb = 32;

if ( mode == .wrap )                       tb = tb & 0x1f;

switch ( vop ){

   case vshl:  tmp = ta << tb;

   case vshr:  tmp = ta >> tb;

}

// saturate, taking into account destination type and merge operations

tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );

d = optSecondaryOp( op2, tmp, c );  // optional secondary operation

d = optMerge( dsel, tmp, c );       // optional merge with c operand
```

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vshl`, `vshr` require `sm_20` or higher.

Examples

```
vshl.s32.u32.u32.clamp  r1, r2, r3;

vshr.u32.u32.u32.wrap   r1, r2, r3.h1;
```

##### 9.7.18.1.3. [Scalar Video Instructions: `vmad`](#scalar-video-instructions-vmad)[](#scalar-video-instructions-vmad "Permalink to this headline")

`vmad`

Integer byte/half-word/word multiply-accumulate.

Syntax

```
// 32-bit scalar operation

vmad.dtype.atype.btype{.sat}{.scale}     d, {-}a{.asel}, {-}b{.bsel},

                                         {-}c;

vmad.dtype.atype.btype.po{.sat}{.scale}  d, a{.asel}, b{.bsel}, c;



.dtype = .atype = .btype = { .u32, .s32 };

.asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };

.scale = { .shr7, .shr15 };
```

Description

Calculate `(a*b) + c`, with optional operand negates, *plus one* mode, and scaling.

The source operands support optional negation with some restrictions. Although PTX syntax allows
separate negation of the `a` and `b` operands, internally this is represented as negation of the
product `(a*b)`. That is, `(a*b)` is negated if and only if exactly one of `a` or `b` is
negated. PTX allows negation of either `(a*b)` or `c`.

The plus one mode (`.po`) computes `(a*b) + c + 1`, which is used in computing averages. Source
operands may not be negated in `.po` mode.

The intermediate result of `(a*b)` is unsigned if atype and btype are unsigned and the product
`(a*b)` is not negated; otherwise, the intermediate result is signed. Input `c` has the same
sign as the intermediate result.

The final result is unsigned if the intermediate result is unsigned and `c` is not negated.

Depending on the sign of the `a` and `b` operands, and the operand negates, the following
combinations of operands are supported for VMAD:

```
 (u32 * u32) + u32  // intermediate unsigned; final unsigned

-(u32 * u32) + s32  // intermediate   signed; final   signed

 (u32 * u32) - u32  // intermediate unsigned; final   signed

 (u32 * s32) + s32  // intermediate   signed; final   signed

-(u32 * s32) + s32  // intermediate   signed; final   signed

 (u32 * s32) - s32  // intermediate   signed; final   signed

 (s32 * u32) + s32  // intermediate   signed; final   signed

-(s32 * u32) + s32  // intermediate   signed; final   signed

 (s32 * u32) - s32  // intermediate   signed; final   signed

 (s32 * s32) + s32  // intermediate   signed; final   signed

-(s32 * s32) + s32  // intermediate   signed; final   signed

 (s32 * s32) - s32  // intermediate   signed; final   signed
```

The intermediate result is optionally scaled via right-shift; this result is sign-extended if the
final result is signed, and zero-extended otherwise.

The final result is optionally saturated to the appropriate 32-bit range based on the type (signed
or unsigned) of the final result.

Semantics

```
// extract byte/half-word/word and sign- or zero-extend

// based on source operand type

ta = partSelectSignExtend( a, atype, asel );

tb = partSelectSignExtend( b, btype, bsel );

signedFinal = isSigned(atype) || isSigned(btype) ||

                                 (a.negate ^ b.negate) || c.negate;

tmp[127:0] = ta * tb;



lsb = 0;

if ( .po )                  {              lsb = 1; } else

if ( a.negate ^ b.negate )  { tmp = ~tmp;  lsb = 1; } else

if ( c.negate )             { c   = ~c;    lsb = 1; }



c128[127:0] = (signedFinal) sext32( c ) : zext ( c );

tmp = tmp + c128 + lsb;

switch( scale ) {

   case .shr7:   result = (tmp >>  7) & 0xffffffffffffffff;

   case .shr15:  result = (tmp >> 15) & 0xffffffffffffffff;

}

if ( .sat ) {

     if (signedFinal) result = CLAMP(result, S32_MAX, S32_MIN);

     else             result = CLAMP(result, U32_MAX, U32_MIN);

}
```

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vmad` requires `sm_20` or higher.

Examples

```
vmad.s32.s32.u32.sat    r0, r1, r2, -r3;

vmad.u32.u32.u32.shr15  r0, r1.h0, r2.h0, r3;
```

##### 9.7.18.1.4. [Scalar Video Instructions: `vset`](#scalar-video-instructions-vset)[](#scalar-video-instructions-vset "Permalink to this headline")

`vset`

Integer byte/half-word/word comparison.

Syntax

```
// 32-bit scalar operation, with optional secondary operation

vset.atype.btype.cmp       d, a{.asel}, b{.bsel};

vset.atype.btype.cmp.op2   d, a{.asel}, b{.bsel}, c;



// 32-bit scalar operation, with optional data merge

vset.atype.btype.cmp  d.dsel, a{.asel}, b{.bsel}, c;



.atype = .btype = { .u32, .s32 };

.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };

.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };

.op2   = { .add, .min, .max };
```

Description

Compare input values using specified comparison, with optional secondary arithmetic operation or
subword data merge.

The intermediate result of the comparison is always unsigned, and therefore destination `d` and
operand `c` are also unsigned.

Semantics

```
// extract byte/half-word/word and sign- or zero-extend

// based on source operand type

ta = partSelectSignExtend( a, atype, asel );

tb = partSelectSignExtend( b, btype, bsel );

tmp = compare( ta, tb, cmp ) ? 1 : 0;

d = optSecondaryOp( op2, tmp, c );    // optional secondary operation

d = optMerge( dsel, tmp, c );         // optional merge with c operand
```

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vset` requires `sm_20` or higher.

Examples

```
vset.s32.u32.lt    r1, r2, r3;

vset.u32.u32.ne    r1, r2, r3.h1;
```

#### 9.7.18.2. [SIMD Video Instructions](#simd-video-instructions)[](#simd-video-instructions "Permalink to this headline")

The SIMD video instructions operate on pairs of 16-bit values and quads of 8-bit values.

The SIMD video instructions are:

* `vadd2`, `vadd4`
* `vsub2`, `vsub4`
* `vavrg2`, `vavrg4`
* `vabsdiff2`, `vabsdiff4`
* `vmin2`, `vmin4`
* `vmax2`, `vmax4`
* `vset2`, `vset4`

PTX includes SIMD video instructions for operation on pairs of 16-bit values and quads of 8-bit
values. The SIMD video instructions execute the following stages:

1. Form input vectors by extracting and sign- or zero-extending byte or half-word values from the
   source operands, to form pairs of signed 17-bit values.
2. Perform a SIMD arithmetic operation on the input pairs.
3. Optionally clamp the result to the appropriate signed or unsigned range, as determinted by the
   destination type.
4. Optionally perform one of the following:

   1. perform a second SIMD merge operation, or
   2. apply a scalar accumulate operation to reduce the intermediate SIMD results to a single
      scalar.

The general format of dual half-word SIMD video instructions is as follows:

```
// 2-way SIMD operation, with second SIMD merge or accumulate

vop2.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;



.dtype = .atype = .btype = { .u32, .s32 };

.mask  = { .h0, .h1, .h10 };

.asel  = .bsel = { .hxy, where x,y are from { 0, 1, 2, 3 } };
```

The general format of quad byte SIMD video instructions is as follows:

```
// 4-way SIMD operation, with second SIMD merge or accumulate

vop4.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;



.dtype = .atype = .btype = { .u32, .s32 };

.mask  = { .b0,

           .b1, .b10

           .b2, .b20, .b21, .b210,

           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };

.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
```

The source and destination operands are all 32-bit registers. The type of each operand (`.u32` or
`.s32`) is specified in the instruction type; all combinations of `dtype`, `atype`, and
`btype` are valid. Using the `atype/btype` and `asel/bsel` specifiers, the input values are
extracted and sign- or zero-extended internally to `.s33` values. The primary operation is then
performed to produce an `.s34` intermediate result. The sign of the intermediate result depends on
`dtype`.

The intermediate result is optionally clamped to the range of the destination type (signed or
unsigned), taking into account the subword destination size in the case of optional data merging.

##### 9.7.18.2.1. [SIMD Video Instructions: `vadd2`, `vsub2`, `vavrg2`, `vabsdiff2`, `vmin2`, `vmax2`](#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2)[](#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2 "Permalink to this headline")

`vadd2`, `vsub2`

Integer dual half-word SIMD addition/subtraction.

`vavrg2`

Integer dual half-word SIMD average.

`vabsdiff2`

Integer dual half-word SIMD absolute value of difference.

`vmin2`, `vmax2`

Integer dual half-word SIMD minimum/maximum.

Syntax

```
// SIMD instruction with secondary SIMD merge operation

vop2.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;



// SIMD instruction with secondary accumulate operation

vop2.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;



 vop2  = { vadd2, vsub2, vavrg2, vabsdiff2, vmin2, vmax2 };

.dtype = .atype = .btype = { .u32, .s32 };

.mask  = { .h0, .h1, .h10 };  // defaults to .h10

.asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };

   .asel defaults to .h10

   .bsel defaults to .h32
```

Description

Two-way SIMD parallel arithmetic operation with secondary operation.

Elements of each dual half-word source to the operation are selected from any of the four half-words
in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected half-words are then operated on in parallel.

The results are optionally clamped to the appropriate range determined by the destination type
(signed or unsigned). Saturation cannot be used with the secondary accumulate operation.

For instructions with a secondary SIMD merge operation:

* For half-word positions indicated in mask, the selected half-word results are copied into
  destination `d`. For all other positions, the corresponding half-word from source operand `c`
  is copied to `d`.

For instructions with a secondary accumulate operation:

* For half-word positions indicated in mask, the selected half-word results are added to operand
  `c`, producing a result in `d`.

Semantics

```
// extract pairs of half-words and sign- or zero-extend

// based on operand type

Va = extractAndSignExt_2( a, b, .asel, .atype );

Vb = extractAndSignExt_2( a, b, .bsel, .btype );

Vc = extractAndSignExt_2( c );



for (i=0; i<2; i++) {

    switch ( vop2 ) {

       case vadd2:             t[i] = Va[i] + Vb[i];

       case vsub2:             t[i] = Va[i] - Vb[i];

       case vavrg2:            if ( ( Va[i] + Vb[i] ) >= 0 ) {

                                   t[i] = ( Va[i] + Vb[i] + 1 ) >> 1;

                               } else {

                                   t[i] = ( Va[i] + Vb[i] ) >> 1;

                               }

       case vabsdiff2:         t[i] = | Va[i] - Vb[i] |;

       case vmin2:             t[i] = MIN( Va[i], Vb[i] );

       case vmax2:             t[i] = MAX( Va[i], Vb[i] );

    }

    if (.sat) {

        if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S16_MAX, S16_MIN );

        else                   t[i] = CLAMP( t[i], U16_MAX, U16_MIN );

    }

}

// secondary accumulate or SIMD merge

mask = extractMaskBits( .mask );

if (.add) {

    d = c;

    for (i=0; i<2; i++) {  d += mask[i] ? t[i] : 0;  }

} else {

    d = 0;

    for (i=0; i<2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }

}
```

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vadd2`, `vsub2`, `varvg2`, `vabsdiff2`, `vmin2`, `vmax2` require `sm_30` or higher.

Examples

```
vadd2.s32.s32.u32.sat  r1, r2, r3, r1;

vsub2.s32.s32.s32.sat  r1.h0, r2.h10, r3.h32, r1;

vmin2.s32.u32.u32.add  r1.h10, r2.h00, r3.h22, r1;
```

##### 9.7.18.2.2. [SIMD Video Instructions: `vset2`](#simd-video-instructions-vset2)[](#simd-video-instructions-vset2 "Permalink to this headline")

`vset2`

Integer dual half-word SIMD comparison.

Syntax

```
// SIMD instruction with secondary SIMD merge operation

vset2.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;



// SIMD instruction with secondary accumulate operation

vset2.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;



.atype = .btype = { .u32, .s32 };

.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };

.mask  = { .h0, .h1, .h10 };  // defaults to .h10

.asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };

   .asel defaults to .h10

   .bsel defaults to .h32
```

Description

Two-way SIMD parallel comparison with secondary operation.

Elements of each dual half-word source to the operation are selected from any of the four half-words
in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected half-words are then compared in parallel.

The intermediate result of the comparison is always unsigned, and therefore the half-words of
destination `d` and operand `c` are also unsigned.

For instructions with a secondary SIMD merge operation:

* For half-word positions indicated in mask, the selected half-word results are copied into
  destination `d`. For all other positions, the corresponding half-word from source operand `b`
  is copied to `d`.

For instructions with a secondary accumulate operation:

* For half-word positions indicated in mask, the selected half-word results are added to operand
  `c`, producing `a` result in `d`.

Semantics

```
// extract pairs of half-words and sign- or zero-extend

// based on operand type

Va = extractAndSignExt_2( a, b, .asel, .atype );

Vb = extractAndSignExt_2( a, b, .bsel, .btype );

Vc = extractAndSignExt_2( c );

for (i=0; i<2; i++) {

    t[i] = compare( Va[i], Vb[i], .cmp ) ? 1 : 0;

}

// secondary accumulate or SIMD merge

mask = extractMaskBits( .mask );

if (.add) {

    d = c;

    for (i=0; i<2; i++) {  d += mask[i] ? t[i] : 0;  }

} else {

    d = 0;

    for (i=0; i<2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }

}
```

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vset2` requires `sm_30` or higher.

Examples

```
vset2.s32.u32.lt      r1, r2, r3, r0;

vset2.u32.u32.ne.add  r1, r2, r3, r0;
```

##### 9.7.18.2.3. [SIMD Video Instructions: `vadd4`, `vsub4`, `vavrg4`, `vabsdiff4`, `vmin4`, `vmax4`](#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4)[](#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4 "Permalink to this headline")

`vadd4`, `vsub4`

Integer quad byte SIMD addition/subtraction.

`vavrg4`

Integer quad byte SIMD average.

`vabsdiff4`

Integer quad byte SIMD absolute value of difference.

`vmin4`, `vmax4`

Integer quad byte SIMD minimum/maximum.

Syntax

```
// SIMD instruction with secondary SIMD merge operation

vop4.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;



// SIMD instruction with secondary accumulate operation

vop4.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;

vop4  = { vadd4, vsub4, vavrg4, vabsdiff4, vmin4, vmax4 };



.dtype = .atype = .btype = { .u32, .s32 };

.mask  = { .b0,

           .b1, .b10

           .b2, .b20, .b21, .b210,

           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };

    defaults to .b3210

.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };

   .asel defaults to .b3210

   .bsel defaults to .b7654
```

Description

Four-way SIMD parallel arithmetic operation with secondary operation.

Elements of each quad byte source to the operation are selected from any of the eight bytes in the
two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected bytes are then operated on in parallel.

The results are optionally clamped to the appropriate range determined by the destination type
(signed or unsigned). Saturation cannot be used with the secondary accumulate operation.

For instructions with a secondary SIMD merge operation:

* For byte positions indicated in mask, the selected byte results are copied into destination
  `d`. For all other positions, the corresponding byte from source operand `c` is copied to
  `d`.

For instructions with a secondary accumulate operation:

* For byte positions indicated in mask, the selected byte results are added to operand `c`,
  producing a result in `d`.

Semantics

```
// extract quads of bytes and sign- or zero-extend

// based on operand type

Va = extractAndSignExt_4( a, b, .asel, .atype );

Vb = extractAndSignExt_4( a, b, .bsel, .btype );

Vc = extractAndSignExt_4( c );

for (i=0; i<4; i++) {

    switch ( vop4 ) {

        case vadd4:            t[i] = Va[i] + Vb[i];

        case vsub4:            t[i] = Va[i] - Vb[i];

        case vavrg4:           if ( ( Va[i] + Vb[i] ) >= 0 ) {

                                   t[i] = ( Va[i] + Vb[i] + 1 ) >> 1;

                               } else {

                                   t[i] = ( Va[i] + Vb[i] ) >> 1;

                               }

        case vabsdiff4:        t[i] = | Va[i] - Vb[i] |;

        case vmin4:            t[i] = MIN( Va[i], Vb[i] );

        case vmax4:            t[i] = MAX( Va[i], Vb[i] );

    }

    if (.sat) {

        if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S8_MAX, S8_MIN );

        else                   t[i] = CLAMP( t[i], U8_MAX, U8_MIN );

    }

}

// secondary accumulate or SIMD merge

mask = extractMaskBits( .mask );

if (.add) {

    d = c;

    for (i=0; i<4; i++) {  d += mask[i] ? t[i] : 0;  }

} else {

    d = 0;

    for (i=0; i<4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }

}
```

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vadd4`, `vsub4`, `varvg4`, `vabsdiff4`, `vmin4`, `vmax4` require `sm_30` or higher.

Examples

```
vadd4.s32.s32.u32.sat  r1, r2, r3, r1;

vsub4.s32.s32.s32.sat  r1.b0, r2.b3210, r3.b7654, r1;

vmin4.s32.u32.u32.add  r1.b00, r2.b0000, r3.b2222, r1;
```

##### 9.7.18.2.4. [SIMD Video Instructions: `vset4`](#simd-video-instructions-vset4)[](#simd-video-instructions-vset4 "Permalink to this headline")

`vset4`

Integer quad byte SIMD comparison.

Syntax

```
// SIMD instruction with secondary SIMD merge operation

vset4.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;



// SIMD instruction with secondary accumulate operation

vset4.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;



.atype = .btype = { .u32, .s32 };

.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };

.mask  = { .b0,

           .b1, .b10

           .b2, .b20, .b21, .b210,

           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };

    defaults to .b3210

.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };

   .asel defaults to .b3210

   .bsel defaults to .b7654
```

Description

Four-way SIMD parallel comparison with secondary operation.

Elements of each quad byte source to the operation are selected from any of the eight bytes in the
two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected bytes are then compared in parallel.

The intermediate result of the comparison is always unsigned, and therefore the bytes of destination
`d` and operand `c` are also unsigned.

For instructions with a secondary SIMD merge operation:

* For byte positions indicated in mask, the selected byte results are copied into destination
  `d`. For all other positions, the corresponding byte from source operand `b` is copied to
  `d`.

For instructions with a secondary accumulate operation:

* For byte positions indicated in mask, the selected byte results are added to operand `c`,
  producing a result in `d`.

Semantics

```
// extract quads of bytes and sign- or zero-extend

// based on operand type

Va = extractAndSignExt_4( a, b, .asel, .atype );

Vb = extractAndSignExt_4( a, b, .bsel, .btype );

Vc = extractAndSignExt_4( c );

for (i=0; i<4; i++) {

    t[i] = compare( Va[i], Vb[i], cmp ) ? 1 : 0;

}

// secondary accumulate or SIMD merge

mask = extractMaskBits( .mask );

if (.add) {

    d = c;

    for (i=0; i<4; i++) {  d += mask[i] ? t[i] : 0;  }

} else {

    d = 0;

    for (i=0; i<4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }

}
```

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vset4` requires `sm_30` or higher.

Examples

```
vset4.s32.u32.lt      r1, r2, r3, r0;

vset4.u32.u32.ne.max  r1, r2, r3, r0;
```