### 5.1.6. Parameter State Space 

The parameter (`.param`) state space is used (1) to pass input arguments from the host to the
kernel, (2a) to declare formal input and return parameters for device functions called from within
kernel execution, and (2b) to declare locally-scoped byte array variables that serve as function
call arguments, typically for passing large structures by value to a function. Kernel function
parameters differ from device function parameters in terms of access and sharing (read-only versus
read-write, per-kernel versus per-thread). Note that PTX ISA versions 1.x supports only kernel
function parameters in .param space; device function parameters were previously restricted to the
register state space. The use of parameter state space for device function parameters was introduced
in PTX ISA version 2.0 and requires target architecture `sm_20` or higher. Additional sub-qualifiers
`::entry` or `::func` can be specified on instructions with `.param` state space to indicate
whether the address refers to kernel function parameter or device function parameter. If no
sub-qualifier is specified with the `.param` state space, then the default sub-qualifier is specific
to and dependent on the exact instruction. For example, `st.param` is equivalent to `st.param::func`
whereas `isspacep.param` is equivalent to `isspacep.param::entry`. Refer to the instruction
description for more details on default sub-qualifier assumption.

Note

The location of parameter space is implementation specific. For example, in some implementations
kernel parameters reside in global memory. No access protection is provided between parameter and
global space in this case. Though the exact location of the kernel parameter space is
implementation specific, the kernel parameter space window is always contained within the global
space window. Similarly, function parameters are mapped to parameter passing registers and/or
stack locations based on the function calling conventions of the *Application Binary Interface
(ABI)*. Therefore, PTX code should make no assumptions about the relative locations or ordering
of `.param` space variables.

#### 5.1.6.1. [Kernel Function Parameters](#kernel-function-parameters)[](#kernel-function-parameters "Permalink to this headline")

Each kernel function definition includes an optional list of parameters. These parameters are
addressable, read-only variables declared in the `.param` state space. Values passed from the host
to the kernel are accessed through these parameter variables using `ld.param` instructions. The
kernel parameter variables are shared across all CTAs from all clusters within a grid.

The address of a kernel parameter may be moved into a register using the `mov` instruction. The
resulting address is in the `.param` state space and is accessed using `ld.param` instructions.

Example

```
.entry foo ( .param .b32 N, .param .align 8 .b8 buffer[64] )

{

    .reg .u32 %n;

    .reg .f64 %d;



    ld.param.u32 %n, [N];

    ld.param.f64 %d, [buffer];

    ...
```

Example

```
.entry bar ( .param .b32 len )

{

    .reg .u32 %ptr, %n;



    mov.u32      %ptr, len;

    ld.param.u32 %n, [%ptr];

    ...
```

Kernel function parameters may represent normal data values, or they may hold addresses to objects
in constant, global, local, or shared state spaces. In the case of pointers, the compiler and
runtime system need information about which parameters are pointers, and to which state space they
point. Kernel parameter attribute directives are used to provide this information at the PTX
level. See [Kernel Function Parameter Attributes](#kernel-function-parameter-attributes)
for a description of kernel parameter attribute
directives.

Note

The current implementation does not allow creation of generic pointers to constant variables
(`cvta.const`) in programs that have pointers to constant buffers passed as kernel parameters.

#### 5.1.6.2. [Kernel Function Parameter Attributes](#kernel-function-parameter-attributes)[](#kernel-function-parameter-attributes "Permalink to this headline")

Kernel function parameters may be declared with an optional .ptr attribute to indicate that a
parameter is a pointer to memory, and also indicate the state space and alignment of the memory
being pointed to. [Kernel Parameter Attribute: .ptr](#kernel-parameter-attribute-ptr)
describes the `.ptr` kernel parameter attribute.

#### 5.1.6.3. [Kernel Parameter Attribute: `.ptr`](#kernel-parameter-attribute-ptr)[](#kernel-parameter-attribute-ptr "Permalink to this headline")

`.ptr`

Kernel parameter alignment attribute.

Syntax

```
.param .type .ptr .space .align N  varname

.param .type .ptr        .align N  varname



.space = { .const, .global, .local, .shared };
```

Description

Used to specify the state space and, optionally, the alignment of memory pointed to by a pointer
type kernel parameter. The alignment value *N*, if present, must be a power of two. If no state
space is specified, the pointer is assumed to be a generic address pointing to one of const, global,
local, or shared memory. If no alignment is specified, the memory pointed to is assumed to be
aligned to a 4 byte boundary.

Spaces between `.ptr`, `.space`, and `.align` may be eliminated to improve readability.

PTX ISA Notes

* Introduced in PTX ISA version 2.2.
* Support for generic addressing of .const space added in PTX ISA version 3.1.

Target ISA Notes

* Supported on all target architectures.

Examples

```
.entry foo ( .param .u32 param1,

             .param .u32 .ptr.global.align 16 param2,

             .param .u32 .ptr.const.align 8 param3,

             .param .u32 .ptr.align 16 param4  // generic address

                                               // pointer

) { .. }
```

#### 5.1.6.4. [Device Function Parameters](#device-function-parameters)[](#device-function-parameters "Permalink to this headline")

PTX ISA version 2.0 extended the use of parameter space to device function parameters. The most
common use is for passing objects by value that do not fit within a PTX register, such as C
structures larger than 8 bytes. In this case, a byte array in parameter space is used. Typically,
the caller will declare a locally-scoped `.param` byte array variable that represents a flattened
C structure or union. This will be passed by value to a callee, which declares a `.param` formal
parameter having the same size and alignment as the passed argument.

Example

```
// pass object of type struct { double d; int y; };

.func foo ( .reg .b32 N, .param .align 8 .b8 buffer[12] )

{

    .reg .f64 %d;

    .reg .s32 %y;



    ld.param.f64 %d, [buffer];

    ld.param.s32 %y, [buffer+8];

    ...

}



// code snippet from the caller

// struct { double d; int y; } mystruct; is flattened, passed to foo

    ...

    .reg .f64 dbl;

    .reg .s32 x;

    .param .align 8 .b8 mystruct;

    ...

    st.param.f64 [mystruct+0], dbl;

    st.param.s32 [mystruct+8], x;

    call foo, (4, mystruct);

    ...
```

See the section on function call syntax for more details.

Function input parameters may be read via `ld.param` and function return parameters may be written
using `st.param`; it is illegal to write to an input parameter or read from a return parameter.

Aside from passing structures by value, `.param` space is also required whenever a formal
parameter has its address taken within the called function. In PTX, the address of a function input
parameter may be moved into a register using the `mov` instruction. Note that the parameter will
be copied to the stack if necessary, and so the address will be in the `.local` state space and is
accessed via `ld.local` and `st.local` instructions. It is not possible to use `mov` to get
the address of or a locally-scoped `.param` space variable. Starting PTX ISA version 6.0, it is
possible to use `mov` instruction to get address of return parameter of device function.

Example

```
// pass array of up to eight floating-point values in buffer

.func foo ( .param .b32 N, .param .b32 buffer[32] )

{

    .reg .u32  %n, %r;

    .reg .f32  %f;

    .reg .pred %p;



    ld.param.u32 %n, [N];

    mov.u32      %r, buffer;  // forces buffer to .local state space

Loop:

    setp.eq.u32  %p, %n, 0;

@%p bra         Done;

    ld.local.f32 %f, [%r];

    ...

    add.u32      %r, %r, 4;

    sub.u32      %n, %n, 1;

    bra          Loop;

Done:

    ...

}
```