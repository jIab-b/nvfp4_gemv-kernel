### 9.7.8. Logic and Shift Instructions 

The logic and shift instructions are fundamentally untyped, performing bit-wise operations on
operands of any type, provided the operands are of the same size. This permits bit-wise operations
on floating point values without having to define a union to access the bits. Instructions `and`,
`or`, `xor`, and `not` also operate on predicates.

The logical shift instructions are:

* `and`
* `or`
* `xor`
* `not`
* `cnot`
* `lop3`
* `shf`
* `shl`
* `shr`

#### 9.7.8.1. [Logic and Shift Instructions: `and`](#logic-and-shift-instructions-and)[](#logic-and-shift-instructions-and "Permalink to this headline")

`and`

Bitwise AND.

Syntax

```
and.type d, a, b;



.type = { .pred, .b16, .b32, .b64 };
```

Description

Compute the bit-wise and operation for the bits in `a` and `b`.

Semantics

```
d = a & b;
```

Notes

The size of the operands must match, but not necessarily the type.

Allowed types include predicate registers.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Examples

```
and.b32  x,q,r;

and.b32  sign,fpvalue,0x80000000;
```

#### 9.7.8.2. [Logic and Shift Instructions: `or`](#logic-and-shift-instructions-or)[](#logic-and-shift-instructions-or "Permalink to this headline")

`or`

Biwise OR.

Syntax

```
or.type d, a, b;



.type = { .pred, .b16, .b32, .b64 };
```

Description

Compute the bit-wise or operation for the bits in `a` and `b`.

Semantics

```
d = a | b;
```

Notes

The size of the operands must match, but not necessarily the type.

Allowed types include predicate registers.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Examples

```
or.b32  mask mask,0x00010001

or.pred  p,q,r;
```

#### 9.7.8.3. [Logic and Shift Instructions: `xor`](#logic-and-shift-instructions-xor)[](#logic-and-shift-instructions-xor "Permalink to this headline")

`xor`

Bitwise exclusive-OR (inequality).

Syntax

```
xor.type d, a, b;



.type = { .pred, .b16, .b32, .b64 };
```

Description

Compute the bit-wise exclusive-or operation for the bits in `a` and `b`.

Semantics

```
d = a ^ b;
```

Notes

The size of the operands must match, but not necessarily the type.

Allowed types include predicate registers.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Examples

```
xor.b32  d,q,r;

xor.b16  d,x,0x0001;
```

#### 9.7.8.4. [Logic and Shift Instructions: `not`](#logic-and-shift-instructions-not)[](#logic-and-shift-instructions-not "Permalink to this headline")

`not`

Bitwise negation; one’s complement.

Syntax

```
not.type d, a;



.type = { .pred, .b16, .b32, .b64 };
```

Description

Invert the bits in `a`.

Semantics

```
d = ~a;
```

Notes

The size of the operands must match, but not necessarily the type.

Allowed types include predicates.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Examples

```
not.b32  mask,mask;

not.pred  p,q;
```

#### 9.7.8.5. [Logic and Shift Instructions: `cnot`](#logic-and-shift-instructions-cnot)[](#logic-and-shift-instructions-cnot "Permalink to this headline")

`cnot`

C/C++ style logical negation.

Syntax

```
cnot.type d, a;



.type = { .b16, .b32, .b64 };
```

Description

Compute the logical negation using C/C++ semantics.

Semantics

```
d = (a==0) ? 1 : 0;
```

Notes

The size of the operands must match, but not necessarily the type.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Examples

```
cnot.b32 d,a;
```

#### 9.7.8.6. [Logic and Shift Instructions: `lop3`](#logic-and-shift-instructions-lop3)[](#logic-and-shift-instructions-lop3 "Permalink to this headline")

`lop3`

Arbitrary logical operation on 3 inputs.

Syntax

```
lop3.b32 d, a, b, c, immLut;

lop3.BoolOp.b32 d|p, a, b, c, immLut, q;



.BoolOp   = { .or , .and };
```

Description

Compute bitwise logical operation on inputs `a`, `b`, `c` and store the result in destination
`d`.

Optionally, `.BoolOp` can be specified to compute the predicate result `p` by performing a
Boolean operation on the destination operand `d` with the predicate `q` in the following manner:

```
p = (d != 0) BoolOp q;
```

The sink symbol ‘\_’ may be used in place of the destination operand `d` when `.BoolOp` qualifier
is specified.

The logical operation is defined by a look-up table which, for 3 inputs, can be represented as an
8-bit value specified by operand `immLut` as described below. `immLut` is an integer constant
that can take values from 0 to 255, thereby allowing up to 256 distinct logical operations on inputs
`a`, `b`, `c`.

For a logical operation `F(a, b, c)` the value of `immLut` can be computed by applying the same
operation to three predefined constant values as follows:

```
ta = 0xF0;

tb = 0xCC;

tc = 0xAA;



immLut = F(ta, tb, tc);
```

Examples:

```
If F = (a & b & c);

immLut = 0xF0 & 0xCC & 0xAA = 0x80



If F = (a | b | c);

immLut = 0xF0 | 0xCC | 0xAA = 0xFE



If F = (a & b & ~c);

immLut = 0xF0 & 0xCC & (~0xAA) = 0x40



If F = ((a & b | c) ^ a);

immLut = (0xF0 & 0xCC | 0xAA) ^ 0xF0 = 0x1A
```

The following table illustrates computation of `immLut` for various logical operations:

| ta | tb | tc | Oper 0 (False) | Oper 1 (ta & tb & tc) | Oper 2 (ta & tb & ~tc) | … | Oper 254 (ta | tb | tc) | Oper 255 (True) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 | … | 0 | 1 |
| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 1 | 0 | 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |
| **immLut** | | | **0x0** | **0x80** | **0x40** | **…** | **0xFE** | **0xFF** |

Semantics

```
F = GetFunctionFromTable(immLut); // returns the function corresponding to immLut value

d = F(a, b, c);

if (BoolOp specified) {

    p = (d != 0) BoolOp q;

}
```

PTX ISA Notes

Introduced in PTX ISA version 4.3.

Support for `.BoolOp` qualifier introduced in PTX ISA version 8.2.

Target ISA Notes

Requires `sm_50` or higher.

Qualifier `.BoolOp` requires `sm_70` or higher.

Examples

```
lop3.b32       d, a, b, c, 0x40;

lop3.or.b32  d|p, a, b, c, 0x3f, q;

lop3.and.b32 _|p, a, b, c, 0x3f, q;
```

#### 9.7.8.7. [Logic and Shift Instructions: `shf`](#logic-and-shift-instructions-shf)[](#logic-and-shift-instructions-shf "Permalink to this headline")

`shf`

Funnel shift.

Syntax

```
shf.l.mode.b32  d, a, b, c;  // left shift

shf.r.mode.b32  d, a, b, c;  // right shift



.mode = { .clamp, .wrap };
```

Description

Shift the 64-bit value formed by concatenating operands `a` and `b` left or right by the amount
specified by the unsigned 32-bit value in `c`. Operand `b` holds bits `63:32` and operand a
holds bits `31:0` of the 64-bit source value. The source is shifted left or right by the clamped
or wrapped value in `c`. For `shf.l`, the most-significant 32-bits of the result are written
into `d`; for `shf.r`, the least-significant 32-bits of the result are written into `d`.

Semantics

```
u32  n = (.mode == .clamp) ? min(c, 32) : c & 0x1f;

switch (shf.dir) {  // shift concatenation of [b, a]

    case shf.l:     // extract 32 msbs

           u32  d = (b << n)      | (a >> (32-n));

    case shf.r:     // extract 32 lsbs

           u32  d = (b << (32-n)) | (a >> n);

}
```

Notes

Use funnel shift for multi-word shift operations and for rotate operations. The shift amount is
limited to the range `0..32` in clamp mode and `0..31` in wrap mode, so shifting multi-word
values by distances greater than 32 requires first moving 32-bit words, then using `shf` to shift
the remaining `0..31` distance.

To shift data sizes greater than 64 bits to the right, use repeated `shf.r` instructions applied
to adjacent words, operating from least-significant word towards most-significant word. At each
step, a single word of the shifted result is computed. The most-significant word of the result is
computed using a `shr.{u32,s32}` instruction, which zero or sign fills based on the instruction
type.

To shift data sizes greater than 64 bits to the left, use repeated `shf.l` instructions applied to
adjacent words, operating from most-significant word towards least-significant word. At each step, a
single word of the shifted result is computed. The least-significant word of the result is computed
using a `shl` instruction.

Use funnel shift to perform 32-bit left or right rotate by supplying the same value for source
arguments `a` and `b`.

PTX ISA Notes

Introduced in PTX ISA version 3.1.

Target ISA Notes

Requires `sm_32` or higher.

Example

```
shf.l.clamp.b32  r3,r1,r0,16;



// 128-bit left shift; n < 32

// [r7,r6,r5,r4] = [r3,r2,r1,r0] << n

shf.l.clamp.b32  r7,r2,r3,n;

shf.l.clamp.b32  r6,r1,r2,n;

shf.l.clamp.b32  r5,r0,r1,n;

shl.b32          r4,r0,n;



// 128-bit right shift, arithmetic; n < 32

// [r7,r6,r5,r4] = [r3,r2,r1,r0] >> n

shf.r.clamp.b32  r4,r0,r1,n;

shf.r.clamp.b32  r5,r1,r2,n;

shf.r.clamp.b32  r6,r2,r3,n;

shr.s32          r7,r3,n;     // result is sign-extended



shf.r.clamp.b32  r1,r0,r0,n;  // rotate right by n; n < 32

shf.l.clamp.b32  r1,r0,r0,n;  // rotate left by n; n < 32



// extract 32-bits from [r1,r0] starting at position n < 32

shf.r.clamp.b32  r0,r0,r1,n;
```

#### 9.7.8.8. [Logic and Shift Instructions: `shl`](#logic-and-shift-instructions-shl)[](#logic-and-shift-instructions-shl "Permalink to this headline")

`shl`

Shift bits left, zero-fill on right.

Syntax

```
shl.type d, a, b;



.type = { .b16, .b32, .b64 };
```

Description

Shift `a` left by the amount specified by unsigned 32-bit value in `b`.

Semantics

```
d = a << b;
```

Notes

Shift amounts greater than the register width *N* are clamped to *N*.

The sizes of the destination and first source operand must match, but not necessarily the type. The
`b` operand must be a 32-bit value, regardless of the instruction type.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Example

```
shl.b32  q,a,2;
```

#### 9.7.8.9. [Logic and Shift Instructions: `shr`](#logic-and-shift-instructions-shr)[](#logic-and-shift-instructions-shr "Permalink to this headline")

`shr`

Shift bits right, sign or zero-fill on left.

Syntax

```
shr.type d, a, b;



.type = { .b16, .b32, .b64,

          .u16, .u32, .u64,

          .s16, .s32, .s64 };
```

Description

Shift `a` right by the amount specified by unsigned 32-bit value in `b`. Signed shifts fill with
the sign bit, unsigned and untyped shifts fill with `0`.

Semantics

```
d = a >> b;
```

Notes

Shift amounts greater than the register width *N* are clamped to *N*.

The sizes of the destination and first source operand must match, but not necessarily the type. The
`b` operand must be a 32-bit value, regardless of the instruction type.

Bit-size types are included for symmetry with `shl`.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

Supported on all target architectures.

Example

```
shr.u16  c,a,2;

shr.s32  i,i,1;

shr.b16  k,i,j;
```