### 9.7.3. Floating-Point Instructions 

Floating-point instructions operate on `.f32` and `.f64` register operands and constant
immediate values. The floating-point instructions are:

* `testp`
* `copysign`
* `add`
* `sub`
* `mul`
* `fma`
* `mad`
* `div`
* `abs`
* `neg`
* `min`
* `max`
* `rcp`
* `sqrt`
* `rsqrt`
* `sin`
* `cos`
* `lg2`
* `ex2`
* `tanh`

Instructions that support rounding modifiers are IEEE-754 compliant. Double-precision instructions
support subnormal inputs and results. Single-precision instructions support subnormal inputs and
results by default for `sm_20` and subsequent targets, and flush subnormal inputs and results to
sign-preserving zero for `sm_1x` targets. The optional `.ftz` modifier on single-precision
instructions provides backward compatibility with `sm_1x` targets by flushing subnormal inputs and
results to sign-preserving zero regardless of the target architecture.

Single-precision `add`, `sub`, `mul`, and `mad` support saturation of results to the range
[0.0, 1.0], with `NaN`s being flushed to positive zero. `NaN` payloads are supported for
double-precision instructions (except for `rcp.approx.ftz.f64` and `rsqrt.approx.ftz.f64`, which
maps input `NaN`s to a canonical `NaN`). Single-precision instructions return an unspecified
`NaN`. Note that future implementations may support `NaN` payloads for single-precision
instructions, so PTX programs should not rely on the specific single-precision `NaN`s being
generated.

[Table 29](#floating-point-instructions-summary-of-floating-point-instructions) summarizes
floating-point instructions in PTX.

Table 29 Summary of Floating-Point Instructions[](#floating-point-instructions-summary-of-floating-point-instructions "Permalink to this table")










| Instruction | .rn | .rz | .rm | .rp | .ftz | .sat | Notes |
| --- | --- | --- | --- | --- | --- | --- | --- |
| `{add,sub,mul}.rnd.f32` | x | x | x | x | x | x | If no rounding modifier is specified, default is `.rn` and instructions may be folded into a multiply-add. |
| `{add,sub,mul}.rnd.f64` | x | x | x | x | n/a | n/a | If no rounding modifier is specified, default is `.rn` and instructions may be folded into a multiply-add. |
| `mad.f32` | n/a | n/a | n/a | n/a | x | x | `.target sm_1x`  No rounding modifier. |
| `{mad,fma}.rnd.f32` | x | x | x | x | x | x | `.target sm_20` or higher  `mad.f32` and `fma.f32` are the same. |
| `{mad,fma}.rnd.f64` | x | x | x | x | n/a | n/a | `mad.f64` and `fma.f64` are the same. |
| `div.full.f32` | n/a | n/a | n/a | n/a | x | n/a | No rounding modifier. |
| `{div,rcp,sqrt}.approx.f32` | n/a | n/a | n/a | n/a | x | n/a | n/a |
| `rcp.approx.ftz.f64` | n/a | n/a | n/a | n/a | x | n/a | `.target sm_20` or higher |
| `{div,rcp,sqrt}.rnd.f32` | x | x | x | x | x | n/a | `.target sm_20` or higher |
| `{div,rcp,sqrt}.rnd.f64` | x | x | x | x | n/a | n/a | `.target sm_20` or higher |
| `{abs,neg,min,max}.f32` | n/a | n/a | n/a | n/a | x | n/a |  |
| `{abs,neg,min,max}.f64` | n/a | n/a | n/a | n/a | n/a | n/a |  |
| `rsqrt.approx.f32` | n/a | n/a | n/a | n/a | x | n/a |  |
| `rsqrt.approx.f64` | n/a | n/a | n/a | n/a | n/a | n/a |  |
| `rsqrt.approx.ftz.f64` | n/a | n/a | n/a | n/a | x | n/a | `.target sm_20` or higher |
| `{sin,cos,lg2,ex2}.approx.f32` | n/a | n/a | n/a | n/a | x | n/a |  |
| `tanh.approx.f32` | n/a | n/a | n/a | n/a | n/a | n/a | `.target sm_75` or higher |

#### 9.7.3.1. [Floating Point Instructions: `testp`](#floating-point-instructions-testp)[](#floating-point-instructions-testp "Permalink to this headline")

`testp`

Test floating-point property.

Syntax

```
testp.op.type  p, a;  // result is .pred



.op   = { .finite, .infinite,

          .number, .notanumber,

          .normal, .subnormal };

.type = { .f32, .f64 };
```

Description

`testp` tests common properties of floating-point numbers and returns a predicate value of `1`
if `True` and `0` if `False`.

`testp.finite`
:   `True` if the input is not infinite or `NaN`

`testp.infinite`
:   `True` if the input is positive or negative infinity

`testp.number`
:   `True` if the input is not `NaN`

`testp.notanumber`
:   `True` if the input is `NaN`

`testp.normal`
:   `True` if the input is a normal number (not `NaN`, not infinity)

`testp.subnormal`
:   `True` if the input is a subnormal number (not `NaN`, not infinity)

As a special case, positive and negative zero are considered normal numbers.

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

Requires `sm_20` or higher.

Examples

```
testp.notanumber.f32  isnan, f0;

testp.infinite.f64    p, X;
```

#### 9.7.3.2. [Floating Point Instructions: `copysign`](#floating-point-instructions-copysign)[](#floating-point-instructions-copysign "Permalink to this headline")

`copysign`

Copy sign of one input to another.

Syntax

```
copysign.type  d, a, b;



.type = { .f32, .f64 };
```

Description

Copy sign bit of `a` into value of `b`, and return the result as `d`.

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

Requires `sm_20` or higher.

Examples

```
copysign.f32  x, y, z;

copysign.f64  A, B, C;
```

#### 9.7.3.3. [Floating Point Instructions: `add`](#floating-point-instructions-add)[](#floating-point-instructions-add "Permalink to this headline")

`add`

Add two values.

Syntax

```
add{.rnd}{.ftz}{.sat}.f32  d, a, b;

add{.rnd}{.ftz}.f32x2      d, a, b;

add{.rnd}.f64              d, a, b;



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Performs addition and writes the resulting value into a destination register.

For `.f32x2` instruction type, forms input vectors of single precision (`.f32`) values from
source operands. Single precision (`.f32`) operands are then added in parallel to produce
`.f32x2` result in destination.

For `.f32x2` instruction type, operands `d`, `a` and `b` have `.b64` type.

Semantics

```
if (type == f32 || type == f64) {

    d = a + b;

} else if (type == f32x2) {

    fA[0] = a[0:31];

    fA[1] = a[32:63];

    fB[0] = b[0:31];

    fB[1] = b[32:63];

    for (i = 0; i < 2; i++) {

        d[i] = fA[i] + fB[i];

    }

}
```

Notes

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

The default value of rounding modifier is `.rn`. Note that an `add` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. An `add` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul`/`add` sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `add.ftz.f32`, `add.ftz.f32x2` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `add.f64` supports subnormal numbers.

    `add.f32` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:

`add.sat.f32` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

`add.f32x2` introduced in PTX ISA version 8.6.

Target ISA Notes

`add.f32` supported on all target architectures.

`add.f64` requires `sm_13` or higher.

Rounding modifiers have the following target requirements:

`.rn`, `.rz`
:   available for all targets

`.rm`, `.rp`
:   for `add.f64`, requires `sm_13` or higher.

    for `add.f32`, requires `sm_20` or higher.

`add.f32x2` requires `sm_100` or higher.

Examples

```
@p  add.rz.ftz.f32  f1,f2,f3;

add.rp.ftz.f32x2    d, a, b;
```

#### 9.7.3.4. [Floating Point Instructions: `sub`](#floating-point-instructions-sub)[](#floating-point-instructions-sub "Permalink to this headline")

`sub`

Subtract one value from another.

Syntax

```
sub{.rnd}{.ftz}{.sat}.f32  d, a, b;

sub{.rnd}{.ftz}.f32x2      d, a, b;

sub{.rnd}.f64              d, a, b;



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Performs subtraction and writes the resulting value into a destination register.

For `.f32x2` instruction type, forms input vectors of single precision (`.f32`) values
from source operands. Single precision (`.f32`) operands are then subtracted in parallel
to produce `.f32x2` result in destination.

For `.f32x2` instruction type, operands `d`, `a` and `b` have `.b64` type.

Semantics

```
if (type == f32 || type == f64) {

    d = a - b;

} else if (type == f32x2) {

    fA[0] = a[0:31];

    fA[1] = a[32:63];

    fB[0] = b[0:31];

    fB[1] = b[32:63];

    for (i = 0; i < 2; i++) {

        d[i] = fA[i] - fB[i];

    }

}
```

Notes

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

The default value of rounding modifier is `.rn`. Note that a `sub` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A `sub` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul`/`sub` sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `sub.ftz.f32`, `sub.ftz.f32x2` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `sub.f64` supports subnormal numbers.

    `sub.f32` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:

`sub.sat.f32` clamps the result to [0.0, 1.0]. NaN results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

`sub.f32x2` introduced in PTX ISA version 8.6.

Target ISA Notes

`sub.f32` supported on all target architectures.

`sub.f64` requires `sm_13` or higher.

Rounding modifiers have the following target requirements:

`.rn`, `.rz`
:   available for all targets

`.rm`, `.rp`
:   for `sub.f64`, requires `sm_13` or higher.

    for `sub.f32`, requires `sm_20` or higher.

`sub.f32x2` requires `sm_100` or higher.

Examples

```
sub.f32 c,a,b;

sub.rn.ftz.f32  f1,f2,f3;
```

#### 9.7.3.5. [Floating Point Instructions: `mul`](#floating-point-instructions-mul)[](#floating-point-instructions-mul "Permalink to this headline")

`mul`

Multiply two values.

Syntax

```
mul{.rnd}{.ftz}{.sat}.f32  d, a, b;

mul{.rnd}{.ftz}.f32x2      d, a, b;

mul{.rnd}.f64              d, a, b;



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Compute the product of two values.

For `.f32x2` instruction type, forms input vectors of single precision (`.f32`) values
from source operands. Single precision (`.f32`) operands are then multiplied in parallel
to produce `.f32x2` result in destination.

For `.f32x2` instruction type, operands `d`, `a` and `b` have `.b64` type.

Semantics

```
if (type == f32 || type == f64) {

    d = a * b;

} else if (type == f32x2) {

    fA[0] = a[0:31];

    fA[1] = a[32:63];

    fB[0] = b[0:31];

    fB[1] = b[32:63];

    for (i = 0; i < 2; i++) {

        d[i] = fA[i] * fB[i];

    }

}
```

Notes

For floating-point multiplication, all operands must be the same size.

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

The default value of rounding modifier is `.rn`. Note that a `mul` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A `mul` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul/add` and `mul/sub` sequences with no rounding modifiers may be
optimized to use fused-multiply-add instructions on the target device.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `mul.ftz.f32`, `mul.ftz.f32x2` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `mul.f64` supports subnormal numbers.

    `mul.f32` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:

`mul.sat.f32` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

`mul.f32x2` introduced in PTX ISA version 8.6.

Target ISA Notes

`mul.f32` supported on all target architectures.

`mul.f64` requires `sm_13` or higher.

Rounding modifiers have the following target requirements:

`.rn`, `.rz`
:   available for all targets

`.rm`, `.rp`
:   for `mul.f64`, requires `sm_13` or higher.

    for `mul.f32`, requires `sm_20` or higher.

`mul.f32x2` requires `sm_100` or higher.

Examples

```
mul.ftz.f32 circumf,radius,pi  // a single-precision multiply
```

#### 9.7.3.6. [Floating Point Instructions: `fma`](#floating-point-instructions-fma)[](#floating-point-instructions-fma "Permalink to this headline")

`fma`

Fused multiply-add.

Syntax

```
fma.rnd{.ftz}{.sat}.f32  d, a, b, c;

fma.rnd{.ftz}.f32x2      d, a, b, c;

fma.rnd.f64              d, a, b, c;



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Performs a fused multiply-add with no loss of precision in the intermediate product and addition.

For `.f32x2` instruction type, forms input vectors of single precision (`.f32`) values from
source operands. Single precision (`.f32`) operands are then operated in parallel to produce
`.f32x2` result in destination.

For `.f32x2` instruction type, operands `d`, `a`, `b` and `c` have `.b64` type.

Semantics

```
if (type == f32 || type == f64) {

    d = a * b + c;

} else if (type == f32x2) {

    fA[0] = a[0:31];

    fA[1] = a[32:63];

    fB[0] = b[0:31];

    fB[1] = b[32:63];

    fC[0] = c[0:31];

    fC[1] = c[32:63];

    for (i = 0; i < 2; i++) {

        d[i] = fA[i] * fB[i] + fC[i];

    }

}
```

Notes

`fma.f32` computes the product of `a` and `b` to infinite precision and then adds `c` to
this product, again in infinite precision. The resulting value is then rounded to single precision
using the rounding mode specified by `.rnd`.

`fma.f64` computes the product of `a` and `b` to infinite precision and then adds `c` to
this product, again in infinite precision. The resulting value is then rounded to double precision
using the rounding mode specified by `.rnd`.

`fma.f64` is the same as `mad.f64`.

Rounding modifiers (no default):

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `fma.ftz.f32`, `fma.ftz.f32x2` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `fma.f64` supports subnormal numbers.

    `fma.f32` is unimplemented for `sm_1x` targets.

Saturation:

`fma.sat.f32` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

`fma.f64` introduced in PTX ISA version 1.4.

`fma.f32` introduced in PTX ISA version 2.0.

`fma.f32x2` introduced in PTX ISA version 8.6.

Target ISA Notes

`fma.f32` requires `sm_20` or higher.

`fma.f64` requires `sm_13` or higher.

`fma.f32x2` requires `sm_100` or higher.

Examples

```
    fma.rn.ftz.f32  w,x,y,z;

@p  fma.rn.f64      d,a,b,c;

    fma.rp.ftz.f32x2 p,q,r,s;
```

#### 9.7.3.7. [Floating Point Instructions: `mad`](#floating-point-instructions-mad)[](#floating-point-instructions-mad "Permalink to this headline")

`mad`

Multiply two values and add a third value.

Syntax

```
mad{.ftz}{.sat}.f32      d, a, b, c;    // .target sm_1x

mad.rnd{.ftz}{.sat}.f32  d, a, b, c;    // .target sm_20

mad.rnd.f64              d, a, b, c;    // .target sm_13 and higher



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Multiplies two values and adds a third, and then writes the resulting value into a destination
register.

Semantics

```
d = a*b + c;
```

Notes

For `.target sm_20` and higher:

* `mad.f32` computes the product of `a` and `b` to infinite precision and then adds `c` to
  this product, again in infinite precision. The resulting value is then rounded to single precision
  using the rounding mode specified by `.rnd`.
* `mad.f64` computes the product of `a` and `b` to infinite precision and then adds `c` to
  this product, again in infinite precision. The resulting value is then rounded to double precision
  using the rounding mode specified by `.rnd`.
* `mad.{f32,f64}` is the same as `fma.{f32,f64}`.

For `.target sm_1x`:

* `mad.f32` computes the product of `a` and `b` at double precision, and then the mantissa is
  truncated to 23 bits, but the exponent is preserved. Note that this is different from computing
  the product with `mul`, where the mantissa can be rounded and the exponent will be clamped. The
  exception for `mad.f32` is when `c = +/-0.0`, `mad.f32` is identical to the result computed
  using separate mul and add instructions. When JIT-compiled for SM 2.0 devices, `mad.f32` is
  implemented as a fused multiply-add (i.e., `fma.rn.ftz.f32`). In this case, `mad.f32` can
  produce slightly different numeric results and backward compatibility is not guaranteed in this
  case.
* `mad.f64` computes the product of `a` and `b` to infinite precision and then adds `c` to
  this product, again in infinite precision. The resulting value is then rounded to double precision
  using the rounding mode specified by `.rnd`. Unlike `mad.f32`, the treatment of subnormal
  inputs and output follows IEEE 754 standard.
* `mad.f64` is the same as `fma.f64`.

Rounding modifiers (no default):

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `mad.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `mad.f64` supports subnormal numbers.

    `mad.f32` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:

`mad.sat.f32` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

In PTX ISA versions 1.4 and later, a rounding modifier is required for `mad.f64`.

Legacy `mad.f64` instructions having no rounding modifier will map to `mad.rn.f64`.

In PTX ISA versions 2.0 and later, a rounding modifier is required for `mad.f32` for `sm_20` and higher targets.

Errata

`mad.f32` requires a rounding modifier for `sm_20` and higher targets. However for PTX ISA
version 3.0 and earlier, ptxas does not enforce this requirement and `mad.f32` silently defaults
to `mad.rn.f32`. For PTX ISA version 3.1, ptxas generates a warning and defaults to
`mad.rn.f32`, and in subsequent releases ptxas will enforce the requirement for PTX ISA version
3.2 and later.

Target ISA Notes

`mad.f32` supported on all target architectures.

`mad.f64` requires `sm_13` or higher.

Rounding modifiers have the following target requirements:

* `.rn`, `.rz`, `.rm`, `.rp` for `mad.f64`, requires `sm_13` or higher.
* `.rn`, `.rz`, `.rm`, `.rp` for `mad.f32`, requires `sm_20` or higher.

Examples

```
@p  mad.f32  d,a,b,c;
```

#### 9.7.3.8. [Floating Point Instructions: `div`](#floating-point-instructions-div)[](#floating-point-instructions-div "Permalink to this headline")

`div`

Divide one value by another.

Syntax

```
div.approx{.ftz}.f32  d, a, b;  // fast, approximate divide

div.full{.ftz}.f32    d, a, b;  // full-range approximate divide

div.rnd{.ftz}.f32     d, a, b;  // IEEE 754 compliant rounding

div.rnd.f64           d, a, b;  // IEEE 754 compliant rounding



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Divides `a` by `b`, stores result in `d`.

Semantics

```
d = a / b;
```

Notes

Fast, approximate single-precision divides:

* `div.approx.f32` implements a fast approximation to divide, computed as `d = a * (1/b)`. For
  `|b|` in [2-126, 2126], the maximum `ulp` error is 2. For 2126 <
  `|b|` < 2128, if `a` is infinity, `div.approx.f32` returns `NaN`, otherwise it
  returns a sign-preserving zero.
* `div.full.f32` implements a relatively fast, full-range approximation that scales operands to
  achieve better accuracy, but is not fully IEEE 754 compliant and does not support rounding
  modifiers. The maximum `ulp` error is 2 across the full range of inputs.

Divide with IEEE 754 compliant rounding:

Rounding modifiers (no default):

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `div.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `div.f64` supports subnormal numbers.

    `div.f32` flushes subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`div.f32` and `div.f64` introduced in PTX ISA version 1.0.

Explicit modifiers `.approx`, `.full`, `.ftz`, and rounding introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, one of `.approx`, `.full`, or `.rnd` is required.

For PTX ISA versions 1.0 through 1.3, `div.f32` defaults to `div.approx.ftz.f32`, and
`div.f64` defaults to `div.rn.f64`.

Target ISA Notes

`div.approx.f32` and `div.full.f32` supported on all target architectures.

`div.rnd.f32` requires `sm_20` or higher.

`div.rn.f64` requires `sm_13` or higher, or `.target map_f64_to_f32`.

`div.{rz,rm,rp}.f64` requires `sm_20` or higher.

Examples

```
div.approx.ftz.f32  diam,circum,3.14159;

div.full.ftz.f32    x, y, z;

div.rn.f64          xd, yd, zd;
```

#### 9.7.3.9. [Floating Point Instructions: `abs`](#floating-point-instructions-abs)[](#floating-point-instructions-abs "Permalink to this headline")

`abs`

Absolute value.

Syntax

```
abs{.ftz}.f32  d, a;

abs.f64        d, a;
```

Description

Take the absolute value of `a` and store the result in `d`.

Semantics

```
d = |a|;
```

Notes

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `abs.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `abs.f64` supports subnormal numbers.

    `abs.f32` flushes subnormal inputs and results to sign-preserving zero.

For `abs.f32`, `NaN` input yields unspecified `NaN`. For `abs.f64`, `NaN` input is passed
through unchanged. Future implementations may comply with the IEEE 754 standard by preserving
payload and modifying only the sign bit.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

`abs.f32` supported on all target architectures.

`abs.f64` requires `sm_13` or higher.

Examples

```
abs.ftz.f32  x,f0;
```

#### 9.7.3.10. [Floating Point Instructions: `neg`](#floating-point-instructions-neg)[](#floating-point-instructions-neg "Permalink to this headline")

`neg`

Arithmetic negate.

Syntax

```
neg{.ftz}.f32  d, a;

neg.f64        d, a;
```

Description

Negate the sign of `a` and store the result in `d`.

Semantics

```
d = -a;
```

Notes

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `neg.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `neg.f64` supports subnormal numbers.

    `neg.f32` flushes subnormal inputs and results to sign-preserving zero.

`NaN` inputs yield an unspecified `NaN`. Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Target ISA Notes

`neg.f32` supported on all target architectures.

`neg.f64` requires `sm_13` or higher.

Examples

```
neg.ftz.f32  x,f0;
```

#### 9.7.3.11. [Floating Point Instructions: `min`](#floating-point-instructions-min)[](#floating-point-instructions-min "Permalink to this headline")

`min`

Find the minimum of given values.

Syntax

```
min{.ftz}{.NaN}{.xorsign.abs}.f32  d, a, b;

min{.ftz}{.NaN}{.abs}.f32          d, a, b, c;

min.f64                            d, a, b;
```

Description

Store the minimum of `a`, `b` and optionally `c` in `d`.

If `.NaN` modifier is specified, then the result is canonical `NaN` if any of the inputs is
`NaN`.

If `.abs` modifier is specified, the magnitude of destination operand `d` is the minimum of
absolute values of both input arguments.

If `.xorsign` modifier is specified, the sign bit of destination `d` is equal to the XOR of the
sign bits of both inputs `a` and `b`. The `.xorsign` qualifier cannot be specified for three
inputs operation.

Qualifier `.xorsign` requires qualifier `.abs` to be specified. In such cases, `.xorsign`
considers the sign bit of both inputs before applying `.abs` operation.

If the result of `min` is `NaN` then the `.xorsign` and `.abs` modifiers will be ignored.

Semantics

```
def min_num (z, x, y) {

    if (isNaN(x) && isNaN(y))

        z = NaN;

    else if (isNaN(x))

        z = y;

    else if (isNaN(y))

        z = x;

    else

        // note: -0.0 < +0.0 here

        z = (x < y) ? x : y;

    return z;

}



def min_nan (z, x, y) {

    if (isNaN(x) || isNaN(y))

        z = NaN;

    else

        // note: -0.0 < +0.0 here

        z = (x < y) ? x : y;

    return z;

}



def two_inputs_min (z, x, y) {

    if (.NaN)

        z = min_nan(z, x, y);

    else

        z = min_num(z, x, y);

    return z;

}



if (.xorsign && !isPresent(c)) {

    xorsign = getSignBit(a) ^ getSignBit(b);

}

if (.abs) {

    a = |a|;

    b = |b|;

    if (isPresent(c)) {

        c = |c|;

    }

}



d = two_inputs_min(d, a, b)

if (isPresent(c)) {

    d = two_inputs_min(d, d, c)

}

if (.xorsign && !isPresent(c) && !isNaN(d)) {

    setSignBit(d, xorsign);

}
```

Notes

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `min.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `min.f64` supports subnormal numbers.

    `min.f32` flushes subnormal inputs and results to sign-preserving zero.

If values of both inputs are 0.0, then +0.0 > -0.0.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

`min.NaN` introduced in PTX ISA version 7.0.

`min.xorsign.abs` introduced in PTX ISA version 7.2.

`min` with three input arguments introduced in PTX ISA version 8.8.

Target ISA Notes

`min.f32` supported on all target architectures.

`min.f64` requires `sm_13` or higher.

`min.NaN` requires `sm_80` or higher.

`min.xorsign.abs` requires `sm_86` or higher.

`min` with three input arguments requires `sm_100` or higher.

Examples

```
@p  min.ftz.f32  z,z,x;

    min.f64      a,b,c;

    // fp32 min with .NaN

    min.NaN.f32  f0,f1,f2;

    // fp32 min with .xorsign.abs

    min.xorsign.abs.f32 Rd, Ra, Rb;
```

#### 9.7.3.12. [Floating Point Instructions: `max`](#floating-point-instructions-max)[](#floating-point-instructions-max "Permalink to this headline")

`max`

Find the maximum of given values.

Syntax

```
max{.ftz}{.NaN}{.xorsign.abs}.f32  d, a, b;

max{.ftz}{.NaN}{.abs}.f32          d, a, b, c;

max.f64                            d, a, b;
```

Description

Store the maximum of `a`, `b` and optionally `c` in `d`.

If `.NaN` modifier is specified, the result is canonical `NaN` if any of the inputs is
`NaN`.

If `.abs` modifier is specified, the magnitude of destination operand `d` is the maximum of
absolute values of the input arguments.

If `.xorsign` modifier is specified, the sign bit of destination `d` is equal to the XOR of the
sign bits of the inputs: `a` and `b`. The `.xorsign` qualifier cannot be specified for three
inputs operation.

Qualifier `.xorsign` requires qualifier `.abs` to be specified. In such cases, `.xorsign`
considers the sign bit of both inputs before applying `.abs` operation.

If the result of `max` is `NaN` then the `.xorsign` and `.abs` modifiers will be ignored.

Semantics

```
def max_num (z, x, y) {

    if (isNaN(x) && isNaN(y))

        z = NaN;

    else if (isNaN(x))

        z = y;

    else if (isNaN(y))

        z = x;

    else

        // note: +0.0 > -0.0 here

        z = (x > y) ? x : y;

    return z;

}



def max_nan (z, x, y) {

    if (isNaN(x) || isNaN(y))

        z = NaN;

    else

        // note: +0.0 > -0.0 here

        z = (x > y) ? x : y;

    return z;

}



def two_inputs_max (z, x, y) {

    if (.NaN)

        z = max_nan(z, x, y);

    else

        z = max_num(z, x, y);

    return z;

}



if (.xorsign && !isPresent(c)) {

    xorsign = getSignBit(a) ^ getSignBit(b);

}

if (.abs) {

    a = |a|;

    b = |b|;

    if (isPresent(c)) {

        c = |c|;

    }

}



d = two_inputs_max (d, a, b)

if (isPresent(c)) {

    d = two_inputs_max (d, d, c)

}



if (.xorsign && !isPresent(c) !isNaN(d)) {

    setSignBit(d, xorsign);

}
```

Notes

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `max.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `max.f64` supports subnormal numbers.

    `max.f32` flushes subnormal inputs and results to sign-preserving zero.

If values of both inputs are 0.0, then +0.0 > -0.0.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

`max.NaN` introduced in PTX ISA version 7.0.

`max.xorsign.abs` introduced in PTX ISA version 7.2.

`max` with three input arguments introduced in PTX ISA version 8.8.

Target ISA Notes

`max.f32` supported on all target architectures.

`max.f64` requires `sm_13` or higher.

`max.NaN` requires `sm_80` or higher.

`max.xorsign.abs` requires `sm_86` or higher.

`max` with three input arguments requires `sm_100` or higher.

Examples

```
max.ftz.f32  f0,f1,f2;

max.f64      a,b,c;

// fp32 max with .NaN

max.NaN.f32  f0,f1,f2;

// fp32 max with .xorsign.abs

max.xorsign.abs.f32 Rd, Ra, Rb;
```

#### 9.7.3.13. [Floating Point Instructions: `rcp`](#floating-point-instructions-rcp)[](#floating-point-instructions-rcp "Permalink to this headline")

`rcp`

Take the reciprocal of a value.

Syntax

```
rcp.approx{.ftz}.f32  d, a;  // fast, approximate reciprocal

rcp.rnd{.ftz}.f32     d, a;  // IEEE 754 compliant rounding

rcp.rnd.f64           d, a;  // IEEE 754 compliant rounding



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Compute `1/a`, store result in `d`.

Semantics

```
d = 1 / a;
```

Notes

Fast, approximate single-precision reciprocal:

`rcp.approx.f32` implements a fast approximation to reciprocal.
The maximum ulp error is 1 across the full range of inputs.

| Input | Result |
| --- | --- |
| -Inf | -0.0 |
| -0.0 | -Inf |
| +0.0 | +Inf |
| +Inf | +0.0 |
| NaN | NaN |

Reciprocal with IEEE 754 compliant rounding:

Rounding modifiers (no default):

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `rcp.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `rcp.f64` supports subnormal numbers.

    `rcp.f32` flushes subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`rcp.f32` and `rcp.f64` introduced in PTX ISA version 1.0. `rcp.rn.f64` and explicit modifiers
`.approx` and `.ftz` were introduced in PTX ISA version 1.4. General rounding modifiers were
added in PTX ISA version 2.0.

For PTX ISA version 1.4 and later, one of `.approx` or `.rnd` is required.

For PTX ISA versions 1.0 through 1.3, `rcp.f32` defaults to `rcp.approx.ftz.f32`, and
`rcp.f64` defaults to `rcp.rn.f64`.

Target ISA Notes

`rcp.approx.f32` supported on all target architectures.

`rcp.rnd.f32` requires `sm_20` or higher.

`rcp.rn.f64` requires `sm_13` or higher, or `.target map_f64_to_f32.`

`rcp.{rz,rm,rp}.f64` requires `sm_20` or higher.

Examples

```
rcp.approx.ftz.f32  ri,r;

rcp.rn.ftz.f32      xi,x;

rcp.rn.f64          xi,x;
```

#### 9.7.3.14. [Floating Point Instructions: `rcp.approx.ftz.f64`](#floating-point-instructions-rcp-approx-ftz-f64)[](#floating-point-instructions-rcp-approx-ftz-f64 "Permalink to this headline")

`rcp.approx.ftz.f64`

Compute a fast, gross approximation to the reciprocal of a value.

Syntax

```
rcp.approx.ftz.f64  d, a;
```

Description

Compute a fast, gross approximation to the reciprocal as follows:

1. extract the most-significant 32 bits of `.f64` operand `a` in 1.11.20 IEEE floating-point
   format (i.e., ignore the least-significant 32 bits of `a`),
2. compute an approximate `.f64` reciprocal of this value using the most-significant 20 bits of
   the mantissa of operand `a`,
3. place the resulting 32-bits in 1.11.20 IEEE floating-point format in the most-significant 32-bits
   of destination `d`,and
4. zero the least significant 32 mantissa bits of `.f64` destination `d`.

Semantics

```
tmp = a[63:32]; // upper word of a, 1.11.20 format

d[63:32] = 1.0 / tmp;

d[31:0] = 0x00000000;
```

Notes

`rcp.approx.ftz.f64` implements a fast, gross approximation to reciprocal.

| Input a[63:32] | Result d[63:32] |
| --- | --- |
| -Inf | -0.0 |
| -subnormal | -Inf |
| -0.0 | -Inf |
| +0.0 | +Inf |
| +subnormal | +Inf |
| +Inf | +0.0 |
| NaN | NaN |

Input `NaN`s map to a canonical `NaN` with encoding `0x7fffffff00000000`.

Subnormal inputs and results are flushed to sign-preserving zero.

PTX ISA Notes

`rcp.approx.ftz.f64` introduced in PTX ISA version 2.1.

Target ISA Notes

`rcp.approx.ftz.f64` requires `sm_20` or higher.

Examples

```
rcp.approx.ftz.f64  xi,x;
```

#### 9.7.3.15. [Floating Point Instructions: `sqrt`](#floating-point-instructions-sqrt)[](#floating-point-instructions-sqrt "Permalink to this headline")

`sqrt`

Take the square root of a value.

Syntax

```
sqrt.approx{.ftz}.f32  d, a; // fast, approximate square root

sqrt.rnd{.ftz}.f32     d, a; // IEEE 754 compliant rounding

sqrt.rnd.f64           d, a; // IEEE 754 compliant rounding



.rnd = { .rn, .rz, .rm, .rp };
```

Description

Compute sqrt(`a`) and store the result in `d`.

Semantics

```
d = sqrt(a);
```

Notes

`sqrt.approx.f32` implements a fast approximation to square root.
The maximum relative error over the entire positive finite floating-point
range is 2-23.

For various corner-case inputs, results of `sqrt` instruction are shown
in below table:

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -normal | NaN |
| -0.0 | -0.0 |
| +0.0 | +0.0 |
| +Inf | +Inf |
| NaN | NaN |

Square root with IEEE 754 compliant rounding:

Rounding modifiers (no default):

`.rn`
:   mantissa LSB rounds to nearest even

`.rz`
:   mantissa LSB rounds towards zero

`.rm`
:   mantissa LSB rounds towards negative infinity

`.rp`
:   mantissa LSB rounds towards positive infinity

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `sqrt.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `sqrt.f64` supports subnormal numbers.

    `sqrt.f32` flushes subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`sqrt.f32` and `sqrt.f64` introduced in PTX ISA version 1.0. `sqrt.rn.f64` and explicit
modifiers `.approx` and `.ftz` were introduced in PTX ISA version 1.4. General rounding
modifiers were added in PTX ISA version 2.0.

For PTX ISA version 1.4 and later, one of `.approx` or `.rnd` is required.

For PTX ISA versions 1.0 through 1.3, `sqrt.f32` defaults to `sqrt.approx.ftz.f32`, and
`sqrt.f64` defaults to `sqrt.rn.f64`.

Target ISA Notes

`sqrt.approx.f32` supported on all target architectures.

`sqrt.rnd.f32` requires `sm_20` or higher.

`sqrt.rn.f64` requires `sm_13` or higher, or `.target map_f64_to_f32`.

`sqrt.{rz,rm,rp}.f64` requires `sm_20` or higher.

Examples

```
sqrt.approx.ftz.f32  r,x;

sqrt.rn.ftz.f32      r,x;

sqrt.rn.f64          r,x;
```

#### 9.7.3.16. [Floating Point Instructions: `rsqrt`](#floating-point-instructions-rsqrt)[](#floating-point-instructions-rsqrt "Permalink to this headline")

`rsqrt`

Take the reciprocal of the square root of a value.

Syntax

```
rsqrt.approx{.ftz}.f32  d, a;

rsqrt.approx.f64        d, a;
```

Description

Compute `1/sqrt(a)` and store the result in `d`.

Semantics

```
d = 1/sqrt(a);
```

Notes

`rsqrt.approx` implements an approximation to the reciprocal square root.

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -normal | NaN |
| -0.0 | -Inf |
| +0.0 | +Inf |
| +Inf | +0.0 |
| NaN | NaN |

The maximum relative error for `rsqrt.f32` over the entire positive
finite floating-point range is 2-22.9.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `rsqrt.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   `rsqrt.f64` supports subnormal numbers.

    `rsqrt.f32` flushes subnormal inputs and results to sign-preserving zero.

Note that `rsqrt.approx.f64` is emulated in software and are relatively slow.

PTX ISA Notes

`rsqrt.f32` and `rsqrt.f64` were introduced in PTX ISA version 1.0. Explicit modifiers
`.approx` and `.ftz` were introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, the `.approx` modifier is required.

For PTX ISA versions 1.0 through 1.3, `rsqrt.f32` defaults to `rsqrt.approx.ftz.f32`, and
`rsqrt.f64` defaults to `rsqrt.approx.f64`.

Target ISA Notes

`rsqrt.f32` supported on all target architectures.

`rsqrt.f64` requires `sm_13` or higher.

Examples

```
rsqrt.approx.ftz.f32  isr, x;

rsqrt.approx.f64      ISR, X;
```

#### 9.7.3.17. [Floating Point Instructions: `rsqrt.approx.ftz.f64`](#floating-point-instructions-rsqrt-approx-ftz-f64)[](#floating-point-instructions-rsqrt-approx-ftz-f64 "Permalink to this headline")

`rsqrt.approx.ftz.f64`

Compute an approximation of the square root reciprocal of a value.

Syntax

```
rsqrt.approx.ftz.f64 d, a;
```

Description

Compute a double-precision (`.f64`) approximation of the square root reciprocal of a value. The
least significant 32 bits of the double-precision (`.f64`) destination `d` are all zeros.

Semantics

```
tmp = a[63:32]; // upper word of a, 1.11.20 format

d[63:32] = 1.0 / sqrt(tmp);

d[31:0] = 0x00000000;
```

Notes

`rsqrt.approx.ftz.f64` implements a fast approximation of the square root reciprocal of a value.

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -subnormal | -Inf |
| -0.0 | -Inf |
| +0.0 | +Inf |
| +subnormal | +Inf |
| +Inf | +0.0 |
| NaN | NaN |

Input `NaN`s map to a canonical `NaN` with encoding `0x7fffffff00000000`.

Subnormal inputs and results are flushed to sign-preserving zero.

PTX ISA Notes

`rsqrt.approx.ftz.f64` introduced in PTX ISA version 4.0.

Target ISA Notes

`rsqrt.approx.ftz.f64` requires `sm_20` or higher.

Examples

```
rsqrt.approx.ftz.f64 xi,x;
```

#### 9.7.3.18. [Floating Point Instructions: `sin`](#floating-point-instructions-sin)[](#floating-point-instructions-sin "Permalink to this headline")

`sin`

Find the sine of a value.

Syntax

```
sin.approx{.ftz}.f32  d, a;
```

Description

Find the sine of the angle `a` (in radians).

Semantics

```
d = sin(a);
```

Notes

`sin.approx.f32` implements a fast approximation to sine.

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -0.0 | -0.0 |
| +0.0 | +0.0 |
| +Inf | NaN |
| NaN | NaN |

The maximum absolute error over input range is as follows:

|  |  |  |
| --- | --- | --- |
| Range | [-2pi .. 2pi] | [-100pi .. +100pi] |
| Error | 2-20.5 | 2-14.7 |

Outside of the range [-100pi .. +100pi], only best effort
is provided. There are no defined error guarantees.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `sin.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   Subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`sin.f32` introduced in PTX ISA version 1.0. Explicit modifiers `.approx` and `.ftz`
introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, the .approx modifier is required.

For PTX ISA versions 1.0 through 1.3, `sin.f32` defaults to `sin.approx.ftz.f32`.

Target ISA Notes

Supported on all target architectures.

Examples

```
sin.approx.ftz.f32  sa, a;
```

#### 9.7.3.19. [Floating Point Instructions: `cos`](#floating-point-instructions-cos)[](#floating-point-instructions-cos "Permalink to this headline")

`cos`

Find the cosine of a value.

Syntax

```
cos.approx{.ftz}.f32  d, a;
```

Description

Find the cosine of the angle `a` (in radians).

Semantics

```
d = cos(a);
```

Notes

`cos.approx.f32` implements a fast approximation to cosine.

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -0.0 | +1.0 |
| +0.0 | +1.0 |
| +Inf | NaN |
| NaN | NaN |

The maximum absolute error over input range is as follows:

|  |  |  |
| --- | --- | --- |
| Range | [-2pi .. 2pi] | [-100pi .. +100pi] |
| Error | 2-20.5 | 2-14.7 |

Outside of the range [-100pi .. +100pi], only best effort
is provided. There are no defined error guarantees.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `cos.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   Subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`cos.f32` introduced in PTX ISA version 1.0. Explicit modifiers `.approx` and `.ftz`
introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, the `.approx` modifier is required.

For PTX ISA versions 1.0 through 1.3, `cos.f32` defaults to `cos.approx.ftz.f32`.

Target ISA Notes

Supported on all target architectures.

Examples

```
cos.approx.ftz.f32  ca, a;
```

#### 9.7.3.20. [Floating Point Instructions: `lg2`](#floating-point-instructions-lg2)[](#floating-point-instructions-lg2 "Permalink to this headline")

`lg2`

Find the base-2 logarithm of a value.

Syntax

```
lg2.approx{.ftz}.f32  d, a;
```

Description

Determine the log2 of `a`.

Semantics

```
d = log(a) / log(2);
```

Notes

`lg2.approx.f32` implements a fast approximation to log2(a).

| Input | Result |
| --- | --- |
| -Inf | NaN |
| -normal | NaN |
| -0.0 | -Inf |
| +0.0 | -Inf |
| +Inf | +Inf |
| NaN | NaN |

The maximum absolute error is 2-22 when the input operand is in the
range (0.5, 2). For positive finite inputs outside of this interval, maximum
relative error is 2-22.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `lg2.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   Subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`lg2.f32` introduced in PTX ISA version 1.0. Explicit modifiers `.approx` and `.ftz`
introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, the `.approx` modifier is required.

For PTX ISA versions 1.0 through 1.3, `lg2.f32` defaults to `lg2.approx.ftz.f32`.

Target ISA Notes

Supported on all target architectures.

Examples

```
lg2.approx.ftz.f32  la, a;
```

#### 9.7.3.21. [Floating Point Instructions: `ex2`](#floating-point-instructions-ex2)[](#floating-point-instructions-ex2 "Permalink to this headline")

`ex2`

Find the base-2 exponential of a value.

Syntax

```
ex2.approx{.ftz}.f32  d, a;
```

Description

Raise 2 to the power `a`.

Semantics

```
d = 2 ^ a;
```

Notes

`ex2.approx.f32` implements a fast approximation to 2a.

| Input | Result |
| --- | --- |
| -Inf | +0.0 |
| -0.0 | +1.0 |
| +0.0 | +1.0 |
| +Inf | +Inf |
| NaN | NaN |

The maximum ulp error is 2 ulp from correctly rounded result across the
full range of inputs.

Subnormal numbers:

`sm_20+`
:   By default, subnormal numbers are supported.

    `ex2.ftz.f32` flushes subnormal inputs and results to sign-preserving zero.

`sm_1x`
:   Subnormal inputs and results to sign-preserving zero.

PTX ISA Notes

`ex2.f32` introduced in PTX ISA version 1.0. Explicit modifiers `.approx` and `.ftz`
introduced in PTX ISA version 1.4.

For PTX ISA version 1.4 and later, the `.approx` modifier is required.

For PTX ISA versions 1.0 through 1.3, `ex2.f32` defaults to `ex2.approx.ftz.f32`.

Target ISA Notes

Supported on all target architectures.

Examples

```
ex2.approx.ftz.f32  xa, a;
```

#### 9.7.3.22. [Floating Point Instructions: `tanh`](#floating-point-instructions-tanh)[](#floating-point-instructions-tanh "Permalink to this headline")

`tanh`

Find the hyperbolic tangent of a value (in radians)

Syntax

```
tanh.approx.f32 d, a;
```

Description

Take hyperbolic tangent value of `a`.

The operands `d` and `a` are of type `.f32`.

Semantics

```
d = tanh(a);
```

Notes

`tanh.approx.f32` implements a fast approximation to FP32 hyperbolic-tangent.

Results of `tanh` for various corner-case inputs are as follows:

| Input | Result |
| --- | --- |
| -Inf | -1.0 |
| -0.0 | -0.0 |
| +0.0 | +0.0 |
| +Inf | 1.0 |
| NaN | NaN |

The maximum relative error over the entire floating point
range is 2-11.
The subnormal numbers are supported.

Note

The subnormal inputs gets passed through to the output since the value of `tanh(x)` for small
values of `x` is approximately the same as `x`.

PTX ISA Notes

Introduced in PTX ISA version 7.0.

Target ISA Notes

Requires `sm_75` or higher.

Examples

```
tanh.approx.f32 ta, a;
```