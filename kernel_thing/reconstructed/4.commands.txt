# Builder commands for python source
# Automatically generated - execute to recreate AST/CUDA
# Mode: structured

# === Full CUDA Source ===
from cuda_ast import *
from builder import CudaBuilder, ASTBuilder, reg, imm, vec, mem, sym

cb = CudaBuilder()
cb.include("stddef.h", system=True)
cb.include("cuda_fp4.h", system=True)
cb.include("cuda_fp16.h", system=True)
cb.define("FP4X2_PER_16B", value='16')
cb.define("FP8X2_PER_16B", value='8')
cb.define("K_BLOCK", value='512')
cb.define("K_BLOCK_SMOL", value='32')
cb.define("ceilDiv", value='(((x) + (y) - 1) / (y))', params=['x', 'y'])
cb.func_begin("get_tile", TypeRef("void"), params=[Param("idx", TypeRef("int")), Param("tile_id", TypeRef("int&")), Param("offset", TypeRef("int&"))], qualifier="__device__", forceinline=True, template=['int TILE_SIZE'])
    cb.stmt('static_assert((TILE_SIZE & (TILE_SIZE - 1)) == 0, "Must be power of 2")')
    cb.stmt('constexpr int mask = TILE_SIZE - 1')
    cb.stmt('constexpr int shift = __builtin_ctz(TILE_SIZE)')
    cb.stmt('tile_id = idx >> shift')
    cb.stmt('offset  = idx & mask')
cb.func_end()
cb.func_begin("mul_and_dup_both", TypeRef("void"), params=[Param("a", TypeRef("const __half2")), Param("b", TypeRef("const __half2")), Param("&low_dup", TypeRef("__half2")), Param("&high_dup", TypeRef("__half2"))], qualifier="__device__", forceinline=True)
    cb.comment('Bit reinterpretation')
    cb.stmt('const uint32_t ra = reinterpret_cast<const uint32_t&>(a)')
    cb.stmt('const uint32_t rb = reinterpret_cast<const uint32_t&>(b)')
    cb.stmt('uint32_t prod32, lo32, hi32')
    cb.asm_raw(['{', 'mul.f16x2 %0, %3, %4;', 'prmt.b32 %1, %0, %0, 0x1010;', 'prmt.b32 %2, %0, %0, 0x3232;', '}'], outputs=[('=&r', 'prod32'), ('=&r', 'lo32'), ('=&r', 'hi32')], inputs=[('r', 'ra'), ('r', 'rb')], clobbers=[])
    cb.stmt('low_dup  = reinterpret_cast<__half2&>(lo32)')
    cb.stmt('high_dup = reinterpret_cast<__half2&>(hi32)')
cb.func_end()
cb.func_begin("dup_both", TypeRef("void"), params=[Param("a", TypeRef("const __half2")), Param("&low_dup", TypeRef("__half2")), Param("&high_dup", TypeRef("__half2"))], qualifier="__device__", forceinline=True)
    cb.comment('Bit reinterpretation')
    cb.stmt('const uint32_t ra = reinterpret_cast<const uint32_t&>(a)')
    cb.stmt('uint32_t lo32, hi32')
    cb.asm_raw(['{', 'prmt.b32 %0, %2, %2, 0x1010;', 'prmt.b32 %1, %2, %2, 0x3232;', '}'], outputs=[('=&r', 'lo32'), ('=&r', 'hi32')], inputs=[('r', 'ra')], clobbers=[])
    cb.stmt('low_dup  = reinterpret_cast<__half2&>(lo32)')
    cb.stmt('high_dup = reinterpret_cast<__half2&>(hi32)')
cb.func_end()
cb.func_begin("fma_reduce_fp16x2", TypeRef("float"), params=[Param("a_reg_half2", TypeRef("const uint32_t*")), Param("b_reg_half2", TypeRef("// Pointer to 16 half2 values (a[0:15]) const uint32_t*")), Param("scale0_h_u32", TypeRef("// Pointer to 16 half2 values (b[0:15]) uint32_t")), Param("uint32_t", TypeRef("// First scale factor as half2 in uint32_t uint32_t scale1_h_u32 // Second scale factor as half2 in"))], qualifier="__device__", forceinline=True)
    cb.stmt('uint32_t acc_h0_u32 = 0')
    cb.stmt('uint32_t acc_h1_u32 = 0')
    cb.stmt('float final_accum = 0.0f')
    cb.stmt('float tmp_x, tmp_y')
    cb.asm_raw(['{', '.reg .b16 h0, h1;', '.reg .f32 f0, f1;', '.reg .b32 rtmp, acc0, acc1, acc2, acc3;', 'mov.b32 acc0, 0;', 'mov.b32 acc1, 0;', 'mov.b32 acc2, 0;', 'mov.b32 acc3, 0;', 'fma.rn.f16x2 acc0, %5, %21, acc0;', 'fma.rn.f16x2 acc2, %13, %29, acc2;', 'fma.rn.f16x2 acc1, %6, %22, acc1;', 'fma.rn.f16x2 acc3, %14, %30, acc3;', 'fma.rn.f16x2 acc0, %7, %23, acc0;', 'fma.rn.f16x2 acc2, %15, %31, acc2;', 'fma.rn.f16x2 acc1, %8, %24, acc1;', 'fma.rn.f16x2 acc3, %16, %32, acc3;', 'fma.rn.f16x2 acc0, %9, %25, acc0;', 'fma.rn.f16x2 acc2, %17, %33, acc2;', 'fma.rn.f16x2 acc1, %10, %26, acc1;', 'fma.rn.f16x2 acc3, %18, %34, acc3;', 'fma.rn.f16x2 acc0, %11, %27, acc0;', 'fma.rn.f16x2 acc2, %19, %35, acc2;', 'fma.rn.f16x2 acc1, %12, %28, acc1;', 'fma.rn.f16x2 acc3, %20, %36, acc3;', 'add.rn.f16x2 acc0, acc1, acc0;', 'add.rn.f16x2 acc2, acc3, acc2;', 'mul.rn.f16x2 acc0, acc0, %37;', 'fma.rn.f16x2 acc0, acc2, %38, acc0;', 'mov.b32 {h0, h1}, acc0;', 'cvt.f32.f16 f0, h0;', 'cvt.f32.f16 f1, h1;', 'add.f32 %4, f0, f1;', '}'], outputs=[('+r', 'acc_h0_u32'), ('+r', 'acc_h1_u32'), ('=f', 'tmp_x'), ('=f', 'tmp_y'), ('+f', 'final_accum')], inputs=[('r', 'a_reg_half2[0]'), ('r', 'a_reg_half2[1]'), ('r', 'a_reg_half2[2]'), ('r', 'a_reg_half2[3]'), ('r', 'a_reg_half2[4]'), ('r', 'a_reg_half2[5]'), ('r', 'a_reg_half2[6]'), ('r', 'a_reg_half2[7]'), ('r', 'a_reg_half2[8]'), ('r', 'a_reg_half2[9]'), ('r', 'a_reg_half2[10]'), ('r', 'a_reg_half2[11]'), ('r', 'a_reg_half2[12]'), ('r', 'a_reg_half2[13]'), ('r', 'a_reg_half2[14]'), ('r', 'a_reg_half2[15]'), ('r', 'b_reg_half2[0]'), ('r', 'b_reg_half2[1]'), ('r', 'b_reg_half2[2]'), ('r', 'b_reg_half2[3]'), ('r', 'b_reg_half2[4]'), ('r', 'b_reg_half2[5]'), ('r', 'b_reg_half2[6]'), ('r', 'b_reg_half2[7]'), ('r', 'b_reg_half2[8]'), ('r', 'b_reg_half2[9]'), ('r', 'b_reg_half2[10]'), ('r', 'b_reg_half2[11]'), ('r', 'b_reg_half2[12]'), ('r', 'b_reg_half2[13]'), ('r', 'b_reg_half2[14]'), ('r', 'b_reg_half2[15]'), ('r', 'scale0_h_u32'), ('r', 'scale1_h_u32')], clobbers=[])
    cb.ret('final_accum')
cb.func_end()
cb.comment('Helper to convert __half2 to uint32_t if needed:')
cb.func_begin("half2_to_u32", TypeRef("uint32_t"), params=[Param("h", TypeRef("__half2"))], qualifier="__device__", forceinline=True)
    cb.ret('*reinterpret_cast<uint32_t*>(&h)')
cb.func_end()
cb.func_begin("load_and_convert_fp8x2_pred", TypeRef("__half2"), params=[Param("ptr", TypeRef("const uint16_t*")), Param("pred", TypeRef("bool"))], qualifier="__device__", forceinline=True)
    cb.stmt('uint32_t out')
    cb.asm_raw(['{', '.reg .b16 raw;', '.reg .pred p;', 'setp.ne.b32 p, %2, 0;', '@p ld.global.cs.u16 raw, [%1];', '@!p mov.b16 raw, 0x3c3c;', 'cvt.rn.f16x2.e4m3x2 %0, raw;', '}'], outputs=[('=r', 'out')], inputs=[('l', 'ptr'), ('r', '(int'), ('=r', 'out_bits'), ('h', 'raw_bits'), ('=r', 'out[0]'), ('=r', 'out[1]'), ('=r', 'out[2]'), ('=r', 'out[3]'), ('=r', 'out[4]'), ('=r', 'out[5]'), ('=r', 'out[6]'), ('=r', 'out[7]'), ('=r', 'out[8]'), ('=r', 'out[9]'), ('=r', 'out[10]'), ('=r', 'out[11]'), ('=r', 'out[12]'), ('=r', 'out[13]'), ('=r', 'out[14]'), ('=r', 'out[15]'), ('+r', 'v.x'), ('+r', 'v.y'), ('+r', 'v.z'), ('+r', 'v.w'), ('r', '(int'), ('l', 'ptr'), ('+r', 'v.x'), ('+r', 'v.y'), ('+r', 'v.z'), ('+r', 'v.w'), ('r', '(int'), ('l', 'ptr')], clobbers=[])
cb.func_end()

cuda_source = cb.build()
