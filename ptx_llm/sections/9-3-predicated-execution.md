## 9.3. Predicated Execution 

In PTX, predicate registers are virtual and have `.pred` as the type specifier. So, predicate
registers can be declared as

```
.reg .pred p, q, r;
```

All instructions have an optional *guard predicate* which controls conditional execution of the
instruction. The syntax to specify conditional execution is to prefix an instruction with `@{!}p`,
where `p` is a predicate variable, optionally negated. Instructions without a guard predicate are
executed unconditionally.

Predicates are most commonly set as the result of a comparison performed by the `setp`
instruction.

As an example, consider the high-level code

```
if (i < n)

    j = j + 1;
```

This can be written in PTX as

```
      setp.lt.s32  p, i, n;    // p = (i < n)

@p    add.s32      j, j, 1;    // if i < n, add 1 to j
```

To get a conditional branch or conditional function call, use a predicate to control the execution
of the branch or call instructions. To implement the above example as a true conditional branch, the
following PTX instruction sequence might be used:

```
      setp.lt.s32  p, i, n;    // compare i to n

@!p   bra  L1;                 // if False, branch over

      add.s32      j, j, 1;

L1:     ...
```

### 9.3.1. [Comparisons](#comparisons)[](#comparisons "Permalink to this headline")

#### 9.3.1.1. [Integer and Bit-Size Comparisons](#integer-and-bit-size-comparisons)[](#integer-and-bit-size-comparisons "Permalink to this headline")

The signed integer comparisons are the traditional `eq` (equal), `ne` (not-equal), `lt`
(less-than), `le` (less-than-or-equal), `gt` (greater-than), and `ge`
(greater-than-or-equal). The unsigned comparisons are `eq`, `ne`, `lo` (lower), `ls`
(lower-or-same), `hi` (higher), and `hs` (higher-or-same). The bit-size comparisons are `eq`
and `ne`; ordering comparisons are not defined for bit-size types.

[Table 22](#integer-and-bit-size-comparisons-operators-for-signed-integer-unsigned-integer-and-bit-size-types)
shows the operators for signed integer, unsigned integer, and bit-size types.

Table 22 Operators for Signed Integer, Unsigned Integer, and Bit-Size Types[](#integer-and-bit-size-comparisons-operators-for-signed-integer-unsigned-integer-and-bit-size-types "Permalink to this table")






| Meaning | Signed Operator | Unsigned Operator | Bit-Size Operator |
| --- | --- | --- | --- |
| `a == b` | `eq` | `eq` | `eq` |
| `a != b` | `ne` | `ne` | `ne` |
| `a < b` | `lt` | `lo` | n/a |
| `a <= b` | `le` | `ls` | n/a |
| `a > b` | `gt` | `hi` | n/a |
| `a >= b` | `ge` | `hs` | n/a |

#### 9.3.1.2. [Floating Point Comparisons](#floating-point-comparisons)[](#floating-point-comparisons "Permalink to this headline")

The ordered floating-point comparisons are `eq`, `ne`, `lt`, `le`, `gt`, and `ge`. If
either operand is `NaN`, the result is
`False`. [Table 23](#floating-point-comparisons-floating-point-operators) lists the floating-point
comparison operators.

Table 23 Floating-Point Comparison Operators[](#floating-point-comparisons-floating-point-operators "Permalink to this table")




| Meaning | Floating-Point Operator |
| --- | --- |
| `a == b && !isNaN(a) && !isNaN(b)` | `eq` |
| `a != b && !isNaN(a) && !isNaN(b)` | `ne` |
| `a < b && !isNaN(a) && !isNaN(b)` | `lt` |
| `a <= b && !isNaN(a) && !isNaN(b)` | `le` |
| `a > b && !isNaN(a) && !isNaN(b)` | `gt` |
| `a >= b && !isNaN(a) && !isNaN(b)` | `ge` |

To aid comparison operations in the presence of `NaN` values, unordered floating-point comparisons
are provided: `equ`, `neu`, `ltu`, `leu`, `gtu`, and `geu`. If both operands are numeric
values (not `NaN`), then the comparison has the same result as its ordered counterpart. If either
operand is `NaN`, then the result of the comparison is `True`.

[Table 24](#floating-point-comparisons-floating-point-operators-nan) lists the floating-point
comparison operators accepting `NaN` values.

Table 24 Floating-Point Comparison Operators Accepting NaN[](#floating-point-comparisons-floating-point-operators-nan "Permalink to this table")




| Meaning | Floating-Point Operator |
| --- | --- |
| `a == b || isNaN(a) || isNaN(b)` | `equ` |
| `a != b || isNaN(a) || isNaN(b)` | `neu` |
| `a < b || isNaN(a) || isNaN(b)` | `ltu` |
| `a <= b || isNaN(a) || isNaN(b)` | `leu` |
| `a > b || isNaN(a) || isNaN(b)` | `gtu` |
| `a >= b || isNaN(a) || isNaN(b)` | `geu` |

To test for `NaN` values, two operators `num` (`numeric`) and `nan` (`isNaN`) are
provided. `num` returns `True` if both operands are numeric values (not `NaN`), and `nan`
returns `True` if either operand is
`NaN`. [Table 25](#floating-point-comparisons-floating-point-operators-testing-nan) lists the
floating-point comparison operators testing for `NaN` values.

Table 25 Floating-Point Comparison Operators Testing for NaN[](#floating-point-comparisons-floating-point-operators-testing-nan "Permalink to this table")




| Meaning | Floating-Point Operator |
| --- | --- |
| `!isNaN(a) && !isNaN(b)` | `num` |
| `isNaN(a) || isNaN(b)` | `nan` |

### 9.3.2. [Manipulating Predicates](#manipulating-predicates)[](#manipulating-predicates "Permalink to this headline")

Predicate values may be computed and manipulated using the following instructions: `and`, `or`,
`xor`, `not`, and `mov`.

There is no direct conversion between predicates and integer values, and no direct way to load or
store predicate register values. However, `setp` can be used to generate a predicate from an
integer, and the predicate-based select (`selp`) instruction can be used to generate an integer
value based on the value of a predicate; for example:

```
selp.u32 %r1,1,0,%p;    // convert predicate to 32-bit value
```