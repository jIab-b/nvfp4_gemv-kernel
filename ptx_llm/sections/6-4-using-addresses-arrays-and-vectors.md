## 6.4. Using Addresses, Arrays, and Vectors 

Using scalar variables as operands is straightforward. The interesting capabilities begin with
addresses, arrays, and vectors.

### 6.4.1. [Addresses as Operands](#addresses-as-operands)[](#addresses-as-operands "Permalink to this headline")

All the memory instructions take an address operand that specifies the memory location being
accessed. This addressable operand is one of:

`[var]`
:   the name of an addressable variable `var`.

`[reg]`
:   an integer or bit-size type register `reg` containing a byte address.

`[reg+immOff]`
:   a sum of register `reg` containing a byte address plus a constant integer byte offset (signed, 32-bit).

`[var+immOff]`
:   a sum of address of addressable variable `var` containing a byte address plus a constant integer
    byte offset (signed, 32-bit).

`[immAddr]`
:   an immediate absolute byte address (unsigned, 32-bit).

`var[immOff]`
:   an array element as described in [Arrays as Operands](#arrays-as-operands).

The register containing an address may be declared as a bit-size type or integer type.

The access size of a memory instruction is the total number of bytes accessed in memory. For
example, the access size of `ld.v4.b32` is 16 bytes, while the access size of `atom.f16x2` is 4
bytes.

The address must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined. For example, among other things, the access
may proceed by silently masking off low-order address bits to achieve proper rounding, or the
instruction may fault.

The address size may be either 32-bit or 64-bit. 128-bit adresses are not supported. Addresses are
zero-extended to the specified width as needed, and truncated if the register width exceeds the
state space address width for the target architecture.

Address arithmetic is performed using integer arithmetic and logical instructions. Examples include
pointer arithmetic and pointer comparisons. All addresses and address computations are byte-based;
there is no support for C-style pointer arithmetic.

The `mov` instruction can be used to move the address of a variable into a pointer. The address is
an offset in the state space in which the variable is declared. Load and store operations move data
between registers and locations in addressable state spaces. The syntax is similar to that used in
many assembly languages, where scalar variables are simply named and addresses are de-referenced by
enclosing the address expression in square brackets. Address expressions include variable names,
address registers, address register plus byte offset, and immediate address expressions which
evaluate at compile-time to a constant address.

Here are a few examples:

```
.shared .u16 x;

.reg    .u16 r0;

.global .v4 .f32 V;

.reg    .v4 .f32 W;

.const  .s32 tbl[256];

.reg    .b32 p;

.reg    .s32 q;



ld.shared.u16   r0,[x];

ld.global.v4.f32 W, [V];

ld.const.s32    q, [tbl+12];

mov.u32         p, tbl;
```

#### 6.4.1.1. [Generic Addressing](#generic-addressing)[](#generic-addressing "Permalink to this headline")

If a memory instruction does not specify a state space, the operation is performed using generic
addressing. The state spaces `.const`, [Kernel Function Parameters](#kernel-function-parameters)
(`.param`), `.local` and `.shared` are modeled as
windows within the generic address space. Each window is defined by a window base and a window size
that is equal to the size of the corresponding state space. A generic address maps to `global`
memory unless it falls within the window for `const`, `local`, or `shared` memory. The
[Kernel Function Parameters](#kernel-function-parameters) (`.param`) window is contained
within the `.global` window. Within each window, a generic address maps to an address in the
underlying state space by subtracting the window base from the generic address.

### 6.4.2. [Arrays as Operands](#arrays-as-operands)[](#arrays-as-operands "Permalink to this headline")

Arrays of all types can be declared, and the identifier becomes an address constant in the space
where the array is declared. The size of the array is a constant in the program.

Array elements can be accessed using an explicitly calculated byte address, or by indexing into the
array using square-bracket notation. The expression within square brackets is either a constant
integer, a register variable, or a simple *register with constant offset* expression, where the
offset is a constant expression that is either added or subtracted from a register variable. If more
complicated indexing is desired, it must be written as an address calculation prior to use. Examples
are:

```
ld.global.u32  s, a[0];

ld.global.u32  s, a[N-1];

mov.u32        s, a[1];  // move address of a[1] into s
```

### 6.4.3. [Vectors as Operands](#vectors-as-operands)[](#vectors-as-operands "Permalink to this headline")

Vector operands can be specified as source and destination operands for instructions. However, when
specified as destination operand, all elements in vector expression must be unique, otherwise behavior
is undefined.
Vectors may also be passed as arguments to called functions.

Vector elements can be extracted from the vector with the suffixes `.x`, `.y`, `.z` and
`.w`, as well as the typical color fields `.r`, `.g`, `.b` and `.a`.

A brace-enclosed list is used for pattern matching to pull apart vectors.

```
.reg .v4 .f32 V;

.reg .f32     a, b, c, d;



mov.v4.f32 {a,b,c,d}, V;
```

Vector loads and stores can be used to implement wide loads and stores, which may improve memory
performance. The registers in the load/store operations can be a vector, or a brace-enclosed list of
similarly typed scalars. Here are examples:

```
ld.global.v4.f32  {a,b,c,d}, [addr+16];

ld.global.v2.u32  V2, [addr+8];
```

Elements in a brace-enclosed vector, say {Ra, Rb, Rc, Rd}, correspond to extracted elements as follows:

```
Ra = V.x = V.r

Rb = V.y = V.g

Rc = V.z = V.b

Rd = V.w = V.a
```

### 6.4.4. [Labels and Function Names as Operands](#labels-and-function-names-as-operands)[](#labels-and-function-names-as-operands "Permalink to this headline")

Labels and function names can be used only in `bra`/`brx.idx` and `call` instructions
respectively. Function names can be used in `mov` instruction to get the address of the function
into a register, for use in an indirect call.

Beginning in PTX ISA version 3.1, the `mov` instruction may be used to take the address of kernel
functions, to be passed to a system call that initiates a kernel launch from the GPU. This feature
is part of the support for CUDA Dynamic Parallelism. See the *CUDA Dynamic Parallelism Programming
Guide* for details.