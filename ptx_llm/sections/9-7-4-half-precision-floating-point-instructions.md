### 9.7.4. Half Precision Floating-Point Instructions 

Half precision floating-point instructions operate on `.f16` and `.f16x2` register operands. The
half precision floating-point instructions are:

* `add`
* `sub`
* `mul`
* `fma`
* `neg`
* `abs`
* `min`
* `max`
* `tanh`
* `ex2`

Half-precision `add`, `sub`, `mul`, and `fma` support saturation of results to the range
[0.0, 1.0], with `NaN`s being flushed to positive zero. Half-precision instructions return an
unspecified `NaN`.

#### 9.7.4.1. [Half Precision Floating Point Instructions: `add`](#half-precision-floating-point-instructions-add)[](#half-precision-floating-point-instructions-add "Permalink to this headline")

`add`

Add two values.

Syntax

```
add{.rnd}{.ftz}{.sat}.f16   d, a, b;

add{.rnd}{.ftz}{.sat}.f16x2 d, a, b;



add{.rnd}.bf16   d, a, b;

add{.rnd}.bf16x2 d, a, b;



.rnd = { .rn };
```

Description

Performs addition and writes the resulting value into a destination register.

For `.f16x2` and `.bf16x2` instruction type, forms input vectors by half word values from source
operands. Half-word operands are then added in parallel to produce `.f16x2` or `.bf16x2` result
in destination.

For `.f16` instruction type, operands `d`, `a` and `b` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d`, `a` and `b` have `.b32` type. For `.bf16`
instruction type, operands `d`, `a`, `b` have `.b16` type. For `.bf16x2` instruction type,
operands `d`, `a`, `b` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = a + b;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = fA[i] + fB[i];

    }

}
```

Notes

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

The default value of rounding modifier is `.rn`. Note that an `add` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. An `add` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul`/`add` sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `add.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:
:   `add.sat.{f16, f16x2}` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 4.2.

`add{.rnd}.bf16` and `add{.rnd}.bf16x2` introduced in PTX ISA version 7.8.

Target ISA Notes

Requires `sm_53` or higher.

`add{.rnd}.bf16` and `add{.rnd}.bf16x2` requires `sm_90` or higher.

Examples

```
// scalar f16 additions

add.f16        d0, a0, b0;

add.rn.f16     d1, a1, b1;

add.bf16       bd0, ba0, bb0;

add.rn.bf16    bd1, ba1, bb1;



// SIMD f16 addition

cvt.rn.f16.f32 h0, f0;

cvt.rn.f16.f32 h1, f1;

cvt.rn.f16.f32 h2, f2;

cvt.rn.f16.f32 h3, f3;

mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2

mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2

add.f16x2  p3, p1, p2;   // SIMD f16x2 addition



// SIMD bf16 addition

cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2

cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2

add.bf16x2  p6, p4, p5;       // SIMD bf16x2 addition



// SIMD fp16 addition

ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2

ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2

add.f16x2       f2, f0, f1;     // SIMD f16x2 addition



ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2

ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2

add.bf16x2      f5, f3, f4;      // SIMD bf16x2 addition
```

#### 9.7.4.2. [Half Precision Floating Point Instructions: `sub`](#half-precision-floating-point-instructions-sub)[](#half-precision-floating-point-instructions-sub "Permalink to this headline")

`sub`

Subtract two values.

Syntax

```
sub{.rnd}{.ftz}{.sat}.f16   d, a, b;

sub{.rnd}{.ftz}{.sat}.f16x2 d, a, b;



sub{.rnd}.bf16   d, a, b;

sub{.rnd}.bf16x2 d, a, b;



.rnd = { .rn };
```

Description

Performs subtraction and writes the resulting value into a destination register.

For `.f16x2` and `.bf16x2` instruction type, forms input vectors by half word values from source
operands. Half-word operands are then subtracted in parallel to produce `.f16x2` or `.bf16x2`
result in destination.

For `.f16` instruction type, operands `d`, `a` and `b` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d`, `a` and `b` have `.b32` type. For `.bf16`
instruction type, operands `d`, `a`, `b` have `.b16` type. For `.bf16x2` instruction type,
operands `d`, `a`, `b` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = a - b;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = fA[i] - fB[i];

    }

}
```

Notes

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

The default value of rounding modifier is `.rn`. Note that a `sub` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A `sub` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul`/`sub` sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `sub.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:
:   `sub.sat.{f16, f16x2}` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 4.2.

`sub{.rnd}.bf16` and `sub{.rnd}.bf16x2` introduced in PTX ISA version 7.8.

Target ISA Notes

Requires `sm_53` or higher.

`sub{.rnd}.bf16` and `sub{.rnd}.bf16x2` requires `sm_90` or higher.

Examples

```
// scalar f16 subtractions

sub.f16        d0, a0, b0;

sub.rn.f16     d1, a1, b1;

sub.bf16       bd0, ba0, bb0;

sub.rn.bf16    bd1, ba1, bb1;



// SIMD f16 subtraction

cvt.rn.f16.f32 h0, f0;

cvt.rn.f16.f32 h1, f1;

cvt.rn.f16.f32 h2, f2;

cvt.rn.f16.f32 h3, f3;

mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2

mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2

sub.f16x2  p3, p1, p2;   // SIMD f16x2 subtraction



// SIMD bf16 subtraction

cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2

cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2

sub.bf16x2  p6, p4, p5;       // SIMD bf16x2 subtraction



// SIMD fp16 subtraction

ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2

ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2

sub.f16x2       f2, f0, f1;     // SIMD f16x2 subtraction



// SIMD bf16 subtraction

ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2

ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2

sub.bf16x2      f5, f3, f4;      // SIMD bf16x2 subtraction
```

#### 9.7.4.3. [Half Precision Floating Point Instructions: `mul`](#half-precision-floating-point-instructions-mul)[](#half-precision-floating-point-instructions-mul "Permalink to this headline")

`mul`

Multiply two values.

Syntax

```
mul{.rnd}{.ftz}{.sat}.f16   d, a, b;

mul{.rnd}{.ftz}{.sat}.f16x2 d, a, b;



mul{.rnd}.bf16   d, a, b;

mul{.rnd}.bf16x2 d, a, b;



.rnd = { .rn };
```

Description

Performs multiplication and writes the resulting value into a destination register.

For `.f16x2` and `.bf16x2` instruction type, forms input vectors by half word values from source
operands. Half-word operands are then multiplied in parallel to produce `.f16x2` or `.bf16x2`
result in destination.

For `.f16` instruction type, operands `d`, `a` and `b` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d`, `a` and `b` have `.b32` type. For `.bf16`
instruction type, operands `d`, `a`, `b` have `.b16` type. For `.bf16x2` instruction type,
operands `d`, `a`, `b` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = a * b;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = fA[i] * fB[i];

    }

}
```

Notes

Rounding modifiers:

`.rn`
:   mantissa LSB rounds to nearest even

The default value of rounding modifier is `.rn`. Note that a `mul` instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A `mul` instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular, `mul`/`add` and `mul/sub` sequences with no rounding modifiers may
be optimized to use fused-multiply-add instructions on the target device.

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `mul.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:
:   `mul.sat.{f16, f16x2}` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.

PTX ISA Notes

Introduced in PTX ISA version 4.2.

`mul{.rnd}.bf16` and `mul{.rnd}.bf16x2` introduced in PTX ISA version 7.8.

Target ISA Notes

Requires `sm_53` or higher.

`mul{.rnd}.bf16` and `mul{.rnd}.bf16x2` requires `sm_90` or higher.

Examples

```
// scalar f16 multiplications

mul.f16        d0, a0, b0;

mul.rn.f16     d1, a1, b1;

mul.bf16       bd0, ba0, bb0;

mul.rn.bf16    bd1, ba1, bb1;



// SIMD f16 multiplication

cvt.rn.f16.f32 h0, f0;

cvt.rn.f16.f32 h1, f1;

cvt.rn.f16.f32 h2, f2;

cvt.rn.f16.f32 h3, f3;

mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2

mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2

mul.f16x2  p3, p1, p2;   // SIMD f16x2 multiplication



// SIMD bf16 multiplication

cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2

cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2

mul.bf16x2  p6, p4, p5;       // SIMD bf16x2 multiplication



// SIMD fp16 multiplication

ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2

ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2

mul.f16x2       f2, f0, f1;     // SIMD f16x2 multiplication



// SIMD bf16 multiplication

ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2

ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2

mul.bf16x2      f5, f3, f4;      // SIMD bf16x2 multiplication
```

#### 9.7.4.4. [Half Precision Floating Point Instructions: `fma`](#half-precision-floating-point-instructions-fma)[](#half-precision-floating-point-instructions-fma "Permalink to this headline")

`fma`

Fused multiply-add

Syntax

```
fma.rnd{.ftz}{.sat}.f16     d, a, b, c;

fma.rnd{.ftz}{.sat}.f16x2   d, a, b, c;

fma.rnd{.ftz}.relu.f16      d, a, b, c;

fma.rnd{.ftz}.relu.f16x2    d, a, b, c;

fma.rnd{.relu}.bf16         d, a, b, c;

fma.rnd{.relu}.bf16x2       d, a, b, c;

fma.rnd.oob.{relu}.type     d, a, b, c;



.rnd = { .rn };
```

Description

Performs a fused multiply-add with no loss of precision in the intermediate product and addition.

For `.f16x2` and `.bf16x2` instruction type, forms input vectors by half word values from source
operands. Half-word operands are then operated in parallel to produce `.f16x2` or `.bf16x2`
result in destination.

For `.f16` instruction type, operands `d`, `a`, `b` and `c` have `.f16` or `.b16`
type. For `.f16x2` instruction type, operands `d`, `a`, `b` and `c` have `.b32`
type. For `.bf16` instruction type, operands `d`, `a`, `b` and `c` have `.b16` type. For
`.bf16x2` instruction type, operands `d`, `a`, `b` and `c` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = a * b + c;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    fC[0] = c[0:15];

    fC[1] = c[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = fA[i] * fB[i] + fC[i];

    }

}
```

Notes

Rounding modifiers (default is `.rn`):

`.rn`
:   mantissa LSB rounds to nearest even

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `fma.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

Saturation modifier:
:   `fma.sat.{f16, f16x2}` clamps the result to [0.0, 1.0]. `NaN` results are flushed to `+0.0f`.
    `fma.relu.{f16, f16x2, bf16, bf16x2}` clamps the result to 0 if negative. `NaN` result is
    converted to canonical `NaN`.

Out Of Bounds modifier:
:   `fma.oob.{f16, f16x2, bf16, bf16x2}` clamps the result to 0 if either of the operands
    is `OOB NaN` (defined under [Tensors](#tensors)) value. The test for the special `NaN` value
    and resultant forcing of the result to +0.0 is performed independently for each of the
    two SIMD operations.

PTX ISA Notes

Introduced in PTX ISA version 4.2.

`fma.relu.{f16, f16x2}` and `fma{.relu}.{bf16, bf16x2}` introduced in PTX ISA version 7.0.

Support for modifier `.oob` introduced in PTX ISA version 8.1.

Target ISA Notes

Requires `sm_53` or higher.

`fma.relu.{f16, f16x2}` and `fma{.relu}.{bf16, bf16x2}` require `sm_80` or higher.

`fma{.oob}.{f16, f16x2, bf16, bf16x2}` requires `sm_90` or higher.

Examples

```
// scalar f16 fused multiply-add

fma.rn.f16         d0, a0, b0, c0;

fma.rn.f16         d1, a1, b1, c1;

fma.rn.relu.f16    d1, a1, b1, c1;

fma.rn.oob.f16      d1, a1, b1, c1;

fma.rn.oob.relu.f16 d1, a1, b1, c1;



// scalar bf16 fused multiply-add

fma.rn.bf16        d1, a1, b1, c1;

fma.rn.relu.bf16   d1, a1, b1, c1;

fma.rn.oob.bf16       d1, a1, b1, c1;

fma.rn.oob.relu.bf16  d1, a1, b1, c1;



// SIMD f16 fused multiply-add

cvt.rn.f16.f32 h0, f0;

cvt.rn.f16.f32 h1, f1;

cvt.rn.f16.f32 h2, f2;

cvt.rn.f16.f32 h3, f3;

mov.b32  p1, {h0, h1}; // pack two f16 to 32bit f16x2

mov.b32  p2, {h2, h3}; // pack two f16 to 32bit f16x2

fma.rn.f16x2  p3, p1, p2, p2;   // SIMD f16x2 fused multiply-add

fma.rn.relu.f16x2  p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with relu saturation mode

fma.rn.oob.f16x2  p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with oob modifier

fma.rn.oob.relu.f16x2 p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with oob modifier and relu saturation mode



// SIMD fp16 fused multiply-add

ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2

ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2

fma.rn.f16x2    f2, f0, f1, f1; // SIMD f16x2 fused multiply-add



// SIMD bf16 fused multiply-add

fma.rn.bf16x2       f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add

fma.rn.relu.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with relu saturation mode

fma.rn.oob.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with oob modifier

fma.rn.oob.relu.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with oob modifier and relu saturation mode
```

#### 9.7.4.5. [Half Precision Floating Point Instructions: `neg`](#half-precision-floating-point-instructions-neg)[](#half-precision-floating-point-instructions-neg "Permalink to this headline")

`neg`

Arithmetic negate.

Syntax

```
neg{.ftz}.f16    d, a;

neg{.ftz}.f16x2  d, a;

neg.bf16         d, a;

neg.bf16x2       d, a;
```

Description

Negate the sign of `a` and store the result in `d`.

For `.f16x2` and `.bf16x2` instruction type, forms input vector by extracting half word values
from the source operand. Half-word operands are then negated in parallel to produce `.f16x2` or
`.bf16x2` result in destination.

For `.f16` instruction type, operands `d` and `a` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d` and `a` have `.b32` type. For `.bf16` instruction
type, operands `d` and `a` have `.b16` type. For `.bf16x2` instruction type, operands `d`
and `a` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = -a;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = -fA[i];

    }

}
```

Notes

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `neg.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

`NaN` inputs yield an unspecified `NaN`. Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.

PTX ISA Notes

Introduced in PTX ISA version 6.0.

`neg.bf16` and `neg.bf16x2` introduced in PTX ISA 7.0.

Target ISA Notes

Requires `sm_53` or higher.

`neg.bf16` and `neg.bf16x2` requires architecture `sm_80` or higher.

Examples

```
neg.ftz.f16  x,f0;

neg.bf16     x,b0;

neg.bf16x2   x1,b1;
```

#### 9.7.4.6. [Half Precision Floating Point Instructions: `abs`](#half-precision-floating-point-instructions-abs)[](#half-precision-floating-point-instructions-abs "Permalink to this headline")

`abs`

Absolute value

Syntax

```
abs{.ftz}.f16    d, a;

abs{.ftz}.f16x2  d, a;

abs.bf16         d, a;

abs.bf16x2       d, a;
```

Description

Take absolute value of `a` and store the result in `d`.

For `.f16x2` and `.bf16x2` instruction type, forms input vector by extracting half word values
from the source operand. Absolute values of half-word operands are then computed in parallel to
produce `.f16x2` or `.bf16x2` result in destination.

For `.f16` instruction type, operands `d` and `a` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d` and `a` have `.f16x2` or `.b32` type. For
`.bf16` instruction type, operands `d` and `a` have `.b16` type. For `.bf16x2` instruction
type, operands `d` and `a` have `.b32` type.

Semantics

```
if (type == f16 || type == bf16) {

    d = |a|;

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    for (i = 0; i < 2; i++) {

         d[i] = |fA[i]|;

    }

}
```

Notes

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `abs.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

`NaN` inputs yield an unspecified `NaN`. Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.

PTX ISA Notes

Introduced in PTX ISA version 6.5.

`abs.bf16` and `abs.bf16x2` introduced in PTX ISA 7.0.

Target ISA Notes

Requires `sm_53` or higher.

`abs.bf16` and `abs.bf16x2` requires architecture `sm_80` or higher.

Examples

```
abs.ftz.f16  x,f0;

abs.bf16     x,b0;

abs.bf16x2   x1,b1;
```

#### 9.7.4.7. [Half Precision Floating Point Instructions: `min`](#half-precision-floating-point-instructions-min)[](#half-precision-floating-point-instructions-min "Permalink to this headline")

`min`

Find the minimum of two values.

Syntax

```
min{.ftz}{.NaN}{.xorsign.abs}.f16      d, a, b;

min{.ftz}{.NaN}{.xorsign.abs}.f16x2    d, a, b;

min{.NaN}{.xorsign.abs}.bf16           d, a, b;

min{.NaN}{.xorsign.abs}.bf16x2         d, a, b;
```

Description

Store the minimum of `a` and `b` in `d`.

For `.f16x2` and `.bf16x2` instruction types, input vectors are formed with half-word values
from source operands. Half-word operands are then processed in parallel to store `.f16x2` or
`.bf16x2` result in destination.

For `.f16` instruction type, operands `d` and `a` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d` and `a` have `.f16x2` or `.b32` type. For
`.bf16` instruction type, operands `d` and `a` have `.b16` type. For `.bf16x2` instruction
type, operands `d` and `a` have `.b32` type.

If `.NaN` modifier is specified, then the result is canonical `NaN` if either of the inputs is
`NaN`.

If `.abs` modifier is specified, the magnitude of destination operand `d` is the minimum of
absolute values of both the input arguments.

If `.xorsign` modifier is specified, the sign bit of destination `d` is equal to the XOR of the
sign bits of both the inputs.

Modifiers `.abs` and `.xorsign` must be specified together and `.xorsign` considers the sign
bit of both inputs before applying `.abs` operation.

If the result of `min` is `NaN` then the `.xorsign` and `.abs` modifiers will be ignored.

Semantics

```
if (type == f16 || type == bf16) {

    if (.xorsign) {

        xorsign = getSignBit(a) ^ getSignBit(b);

        if (.abs) {

            a = |a|;

            b = |b|;

        }

    }

    if (isNaN(a) && isNaN(b))              d = NaN;

    if (.NaN && (isNaN(a) || isNaN(b)))    d = NaN;

    else if (isNaN(a))                     d = b;

    else if (isNaN(b))                     d = a;

    else                                   d = (a < b) ? a : b;

    if (.xorsign && !isNaN(d)) {

         setSignBit(d, xorsign);

    }

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    for (i = 0; i < 2; i++) {

        if (.xorsign) {

            xorsign = getSignBit(fA[i]) ^ getSignBit(fB[i]);

            if (.abs) {

               fA[i] = |fA[i]|;

               fB[i] = |fB[i]|;

           }

        }

        if (isNaN(fA[i]) && isNaN(fB[i]))              d[i] = NaN;

        if (.NaN && (isNaN(fA[i]) || isNaN(fB[i])))    d[i] = NaN;

        else if (isNaN(fA[i]))                         d[i] = fB[i];

        else if (isNaN(fB[i]))                         d[i] = fA[i];

        else                                           d[i] = (fA[i] < fB[i]) ? fA[i] : fB[i];

        if (.xorsign && !isNaN(d[i])) {

            setSignBit(d[i], xorsign);

        }

    }

}
```

Notes

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `min.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

If values of both inputs are 0.0, then +0.0 > -0.0.

PTX ISA Notes

Introduced in PTX ISA version 7.0.

`min.xorsign` introduced in PTX ISA version 7.2.

Target ISA Notes

Requires `sm_80` or higher.

`min.xorsign.abs` support requires `sm_86` or higher.

Examples

```
min.ftz.f16       h0,h1,h2;

min.f16x2         b0,b1,b2;

// SIMD fp16 min with .NaN

min.NaN.f16x2     b0,b1,b2;

min.bf16          h0, h1, h2;

// SIMD bf16 min with NaN

min.NaN.bf16x2    b0, b1, b2;

// scalar bf16 min with xorsign.abs

min.xorsign.abs.bf16 Rd, Ra, Rb
```

#### 9.7.4.8. [Half Precision Floating Point Instructions: `max`](#half-precision-floating-point-instructions-max)[](#half-precision-floating-point-instructions-max "Permalink to this headline")

`max`

Find the maximum of two values.

Syntax

```
max{.ftz}{.NaN}{.xorsign.abs}.f16      d, a, b;

max{.ftz}{.NaN}{.xorsign.abs}.f16x2    d, a, b;

max{.NaN}{.xorsign.abs}.bf16           d, a, b;

max{.NaN}{.xorsign.abs}.bf16x2         d, a, b;
```

Description

Store the maximum of `a` and `b` in `d`.

For `.f16x2` and `.bf16x2` instruction types, input vectors are formed with half-word values
from source operands. Half-word operands are then processed in parallel to store `.f16x2` or
`.bf16x2` result in destination.

For `.f16` instruction type, operands `d` and `a` have `.f16` or `.b16` type. For
`.f16x2` instruction type, operands `d` and `a` have `.f16x2` or `.b32` type. For
`.bf16` instruction type, operands `d` and `a` have `.b16` type. For `.bf16x2` instruction
type, operands `d` and `a` have `.b32` type.

If `.NaN` modifier is specified, the result is canonical `NaN` if either of the inputs is
`NaN`.

If `.abs` modifier is specified, the magnitude of destination operand `d` is the maximum of
absolute values of both the input arguments.

If `.xorsign` modifier is specified, the sign bit of destination `d` is equal to the XOR of the
sign bits of both the inputs.

Modifiers `.abs` and `.xorsign` must be specified together and `.xorsign` considers the sign
bit of both inputs before applying `.abs` operation.

If the result of `max` is `NaN` then the `.xorsign` and `.abs` modifiers will be ignored.

Semantics

```
if (type == f16 || type == bf16) {

    if (.xorsign) {

        xorsign = getSignBit(a) ^ getSignBit(b);

        if (.abs) {

            a = |a|;

            b = |b|;

        }

    }

    if (isNaN(a) && isNaN(b))              d = NaN;

    if (.NaN && (isNaN(a) || isNaN(b)))    d = NaN;

    else if (isNaN(a))                     d = b;

    else if (isNaN(b))                     d = a;

    else                                   d = (a > b) ? a : b;

    if (.xorsign && !isNaN(d)) {

         setSignBit(d, xorsign);

    }

} else if (type == f16x2 || type == bf16x2) {

    fA[0] = a[0:15];

    fA[1] = a[16:31];

    fB[0] = b[0:15];

    fB[1] = b[16:31];

    for (i = 0; i < 2; i++) {

        if (.xorsign) {

            xorsign = getSignBit(fA[i]) ^ getSignBit(fB[i]);

            if (.abs) {

                fA[i] = |fA[i]|;

                fB[i] = |fB[i]|;

            }

        }

        if (isNaN(fA[i]) && isNaN(fB[i]))              d[i] = NaN;

        if (.NaN && (isNaN(fA[i]) || isNaN(fB[i])))    d[i] = NaN;

        else if (isNaN(fA[i]))                         d[i] = fB[i];

        else if (isNaN(fB[i]))                         d[i] = fA[i];

        else                                           d[i] = (fA[i] > fB[i]) ? fA[i] : fB[i];

        if (.xorsign && !isNaN(fA[i])) {

            setSignBit(d[i], xorsign);

        }

    }

}
```

Notes

Subnormal numbers:
:   By default, subnormal numbers are supported.
    `max.ftz.{f16, f16x2}` flushes subnormal inputs and results to sign-preserving zero.

If values of both inputs are 0.0, then +0.0 > -0.0.

PTX ISA Notes

Introduced in PTX ISA version 7.0.

`max.xorsign.abs` introduced in PTX ISA version 7.2.

Target ISA Notes

Requires `sm_80` or higher.

`max.xorsign.abs` support requires `sm_86` or higher.

Examples

```
max.ftz.f16       h0,h1,h2;

max.f16x2         b0,b1,b2;

// SIMD fp16 max with NaN

max.NaN.f16x2     b0,b1,b2;

// scalar f16 max with xorsign.abs

max.xorsign.abs.f16 Rd, Ra, Rb;

max.bf16          h0, h1, h2;

// scalar bf16 max and NaN

max.NaN.bf16x2    b0, b1, b2;

// SIMD bf16 max with xorsign.abs

max.xorsign.abs.bf16x2 Rd, Ra, Rb;
```

#### 9.7.4.9. [Half Precision Floating Point Instructions: `tanh`](#half-precision-floating-point-instructions-tanh)[](#half-precision-floating-point-instructions-tanh "Permalink to this headline")

`tanh`

Find the hyperbolic tangent of a value (in radians)

Syntax

```
tanh.approx.type d, a;



.type = {.f16, .f16x2, .bf16, .bf16x2}
```

Description

Take hyperbolic tangent value of `a`.

The type of operands `d` and `a` are as specified by `.type`.

For `.f16x2` or `.bf16x2` instruction type, each of the half-word operands are operated in
parallel and the results are packed appropriately into a `.f16x2` or `.bf16x2`.

Semantics

```
if (.type == .f16 || .type == .bf16) {

  d = tanh(a)

} else if (.type == .f16x2 || .type == .bf16x2) {

  fA[0] = a[0:15];

  fA[1] = a[16:31];

  d[0] = tanh(fA[0])

  d[1] = tanh(fA[1])

}
```

Notes

`tanh.approx.{f16, f16x2, bf16, bf16x2}` implements an approximate hyperbolic tangent in the
target format.

Results of `tanh` for various corner-case inputs are as follows:

| Input | Result |
| --- | --- |
| -Inf | -1.0 |
| -0.0 | -0.0 |
| +0.0 | +0.0 |
| +Inf | 1.0 |
| NaN | NaN |

The maximum absolute error for `.f16` type is 2-10.987. The maximum absolute error for `.bf16`
type is 2-8.

The subnormal numbers are supported.

PTX ISA Notes

Introduced in PTX ISA version 7.0.

`tanh.approx.{bf16/bf16x2}` introduced in PTX ISA version 7.8.

Target ISA Notes

Requires `sm_75` or higher.

`tanh.approx.{bf16/bf16x2}` requires `sm_90` or higher.

Examples

```
tanh.approx.f16    h1, h0;

tanh.approx.f16x2  hd1, hd0;

tanh.approx.bf16   b1, b0;

tanh.approx.bf16x2 hb1, hb0;
```

#### 9.7.4.10. [Half Precision Floating Point Instructions: `ex2`](#half-precision-floating-point-instructions-ex2)[](#half-precision-floating-point-instructions-ex2 "Permalink to this headline")

`ex2`

Find the base-2 exponent of input.

Syntax

```
ex2.approx.atype     d, a;

ex2.approx.ftz.btype d, a;



.atype = { .f16,  .f16x2}

.btype = { .bf16, .bf16x2}
```

Description

Raise 2 to the power `a`.

The type of operands `d` and `a` are as specified by `.type`.

For `.f16x2` or `.bf16x2` instruction type, each of the half-word operands are operated in
parallel and the results are packed appropriately into a `.f16x2` or `.bf16x2`.

Semantics

```
if (.type == .f16 || .type == .bf16) {

  d = 2 ^ a

} else if (.type == .f16x2 || .type == .bf16x2) {

  fA[0] = a[0:15];

  fA[1] = a[16:31];

  d[0] = 2 ^ fA[0]

  d[1] = 2 ^ fA[1]

}
```

Notes

`ex2.approx.{f16, f16x2, bf16, bf16x2}` implement a fast approximation to 2a.

For the `.f16` type, subnormal inputs are supported. `ex2.approx.ftz.bf16` flushes subnormal
inputs and results to sign-preserving zero.

Results of `ex2.approx.ftz.bf16` for various corner-case inputs are as follows:

| Input | Result |
| --- | --- |
| -Inf | +0.0 |
| -subnormal | +1.0 |
| -0.0 | +1.0 |
| +0.0 | +1.0 |
| +subnormal | +1.0 |
| +Inf | +Inf |
| NaN | NaN |

Results of `ex2.approx.f16` for various corner-case inputs are as follows:

| Input | Result |
| --- | --- |
| -Inf | +0.0 |
| -0.0 | +1.0 |
| +0.0 | +1.0 |
| +Inf | +Inf |
| NaN | NaN |

The maximum relative error for `.f16` type is 2-9.9. The maximum relative error for `.bf16` type
is 2-7.

PTX ISA Notes

Introduced in PTX ISA version 7.0.

`ex2.approx.ftz.{bf16/bf16x2}` introduced in PTX ISA version 7.8.

Target ISA Notes

Requires `sm_75` or higher.

`ex2.approx.ftz.{bf16/bf16x2}` requires `sm_90` or higher.

Examples

```
ex2.approx.f16         h1, h0;

ex2.approx.f16x2       hd1, hd0;

ex2.approx.ftz.bf16    b1, b2;

ex2.approx.ftz.bf16x2  hb1, hb2;
```