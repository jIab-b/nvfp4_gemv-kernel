## 5.4. Variables 

In PTX, a variable declaration describes both the variable’s type and its state space. In addition
to fundamental types, PTX supports types for simple aggregate objects such as vectors and arrays.

### 5.4.1. [Variable Declarations](#variable-declarations)[](#variable-declarations "Permalink to this headline")

All storage for data is specified with variable declarations. Every variable must reside in one of
the state spaces enumerated in the previous section.

A variable declaration names the space in which the variable resides, its type and size, its name,
an optional array size, an optional initializer, and an optional fixed address for the variable.

Predicate variables may only be declared in the register state space.

Examples

```
.global .u32 loc;

.reg    .s32 i;

.const  .f32 bias[] = {-1.0, 1.0};

.global .u8  bg[4] = {0, 0, 0, 0};

.reg    .v4 .f32 accel;

.reg    .pred p, q, r;
```

### 5.4.2. [Vectors](#vectors)[](#vectors "Permalink to this headline")

Limited-length vector types are supported. Vectors of length 2 and 4 of any non-predicate
fundamental type can be declared by prefixing the type with `.v2` or `.v4`. Vectors must be
based on a fundamental type, and they may reside in the register space. Vectors cannot exceed
128-bits in length; for example, `.v4 .f64` is not allowed. Three-element vectors may be
handled by using a `.v4` vector, where the fourth element provides padding. This is a common case
for three-dimensional grids, textures, etc.

Examples

```
.global .v4 .f32 V;   // a length-4 vector of floats

.shared .v2 .u16 uv;  // a length-2 vector of unsigned ints

.global .v4 .b8  v;   // a length-4 vector of bytes
```

By default, vector variables are aligned to a multiple of their overall size (vector length times
base-type size), to enable vector load and store instructions which require addresses aligned to a
multiple of the access size.

### 5.4.3. [Array Declarations](#array-declarations)[](#array-declarations "Permalink to this headline")

Array declarations are provided to allow the programmer to reserve space. To declare an array, the
variable name is followed with dimensional declarations similar to fixed-size array declarations
in C. The size of each dimension is a constant expression.

Examples

```
.local  .u16 kernel[19][19];

.shared .u8  mailbox[128];
```

The size of the array specifies how many elements should be reserved. For the declaration of array
*kernel* above, 19\*19 = 361 halfwords are reserved, for a total of 722 bytes.

When declared with an initializer, the first dimension of the array may be omitted. The size of the
first array dimension is determined by the number of elements in the array initializer.

Examples

```
.global .u32 index[] = { 0, 1, 2, 3, 4, 5, 6, 7 };

.global .s32 offset[][2] = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} };
```

Array *index* has eight elements, and array *offset* is a 4x2 array.

### 5.4.4. [Initializers](#initializers)[](#initializers "Permalink to this headline")

Declared variables may specify an initial value using a syntax similar to C/C++, where the variable
name is followed by an equals sign and the initial value or values for the variable. A scalar takes
a single value, while vectors and arrays take nested lists of values inside of curly braces (the
nesting matches the dimensionality of the declaration).

As in C, array initializers may be incomplete, i.e., the number of initializer elements may be less
than the extent of the corresponding array dimension, with remaining array locations initialized to
the default value for the specified array type.

Examples

```
.const  .f32 vals[8] = { 0.33, 0.25, 0.125 };

.global .s32 x[3][2] = { {1,2}, {3} };
```

is equivalent to

```
.const  .f32 vals[8] = { 0.33, 0.25, 0.125, 0.0, 0.0, 0.0, 0.0, 0.0 };

.global .s32 x[3][2] = { {1,2}, {3,0}, {0,0} };
```

Currently, variable initialization is supported only for constant and global state spaces. Variables
in constant and global state spaces with no explicit initializer are initialized to zero by
default. Initializers are not allowed in external variable declarations.

Variable names appearing in initializers represent the address of the variable; this can be used to
statically initialize a pointer to a variable. Initializers may also contain *var+offset*
expressions, where *offset* is a byte offset added to the address of *var*. Only variables in
`.global` or `.const` state spaces may be used in initializers. By default, the resulting
address is the offset in the variable’s state space (as is the case when taking the address of a
variable with a `mov` instruction). An operator, `generic()`, is provided to create a generic
address for variables used in initializers.

Starting PTX ISA version 7.1, an operator `mask()` is provided, where `mask` is an integer
immediate. The only allowed expressions in the `mask()` operator are integer constant expression
and symbol expression representing address of variable. The `mask()` operator extracts `n`
consecutive bits from the expression used in initializers and inserts these bits at the lowest
position of the initialized variable. The number `n` and the starting position of the bits to be
extracted is specified by the integer immediate `mask`. PTX ISA version 7.1 only supports
extracting a single byte starting at byte boundary from the address of the variable. PTX ISA version
7.3 supports Integer constant expression as an operand in the `mask()` operator.

Supported values for `mask` are: 0xFF, 0xFF00, 0XFF0000, 0xFF000000, 0xFF00000000, 0xFF0000000000,
0xFF000000000000, 0xFF00000000000000.

Examples

```
.const  .u32 foo = 42;

.global .u32 bar[] = { 2, 3, 5 };

.global .u32 p1 = foo;          // offset of foo in .const space

.global .u32 p2 = generic(foo); // generic address of foo



// array of generic-address pointers to elements of bar

.global .u32 parr[] = { generic(bar), generic(bar)+4,

generic(bar)+8 };



// examples using mask() operator are pruned for brevity

.global .u8 addr[] = {0xff(foo), 0xff00(foo), 0xff0000(foo), ...};



.global .u8 addr2[] = {0xff(foo+4), 0xff00(foo+4), 0xff0000(foo+4),...}



.global .u8 addr3[] = {0xff(generic(foo)), 0xff00(generic(foo)),...}



.global .u8 addr4[] = {0xff(generic(foo)+4), 0xff00(generic(foo)+4),...}



// mask() operator with integer const expression

.global .u8 addr5[] = { 0xFF(1000 + 546), 0xFF00(131187), ...};
```

Note

PTX 3.1 redefines the default addressing for global variables in initializers, from generic
addresses to offsets in the global state space. Legacy PTX code is treated as having an implicit
`generic()` operator for each global variable used in an initializer. PTX 3.1 code should
either include explicit `generic()` operators in initializers, use `cvta.global` to form
generic addresses at runtime, or load from the non-generic address using `ld.global`.

Device function names appearing in initializers represent the address of the first instruction in
the function; this can be used to initialize a table of function pointers to be used with indirect
calls. Beginning in PTX ISA version 3.1, kernel function names can be used as initializers e.g. to
initialize a table of kernel function pointers, to be used with CUDA Dynamic Parallelism to launch
kernels from GPU. See the *CUDA Dynamic Parallelism Programming Guide* for details.

Labels cannot be used in initializers.

Variables that hold addresses of variables or functions should be of type `.u8` or `.u32` or
`.u64`.

Type `.u8` is allowed only if the `mask()` operator is used.

Initializers are allowed for all types except `.f16`, `.f16x2` and `.pred`.

Examples

```
.global .s32 n = 10;

.global .f32 blur_kernel[][3]

               = {{.05,.1,.05},{.1,.4,.1},{.05,.1,.05}};



.global .u32 foo[] = { 2, 3, 5, 7, 9, 11 };

.global .u64 ptr = generic(foo);   // generic address of foo[0]

.global .u64 ptr = generic(foo)+8; // generic address of foo[2]
```

### 5.4.5. [Alignment](#alignment)[](#alignment "Permalink to this headline")

Byte alignment of storage for all addressable variables can be specified in the variable
declaration. Alignment is specified using an optional `.align` *byte-count* specifier immediately
following the state-space specifier. The variable will be aligned to an address which is an integer
multiple of byte-count. The alignment value byte-count must be a power of two. For arrays, alignment
specifies the address alignment for the starting address of the entire array, not for individual
elements.

The default alignment for scalar and array variables is to a multiple of the base-type size. The
default alignment for vector variables is to a multiple of the overall vector size.

Examples

```
 // allocate array at 4-byte aligned address.  Elements are bytes.

.const .align 4 .b8 bar[8] = {0,0,0,0,2,0,0,0};
```

Note that all PTX instructions that access memory require that the address be aligned to a multiple
of the access size. The access size of a memory instruction is the total number of bytes accessed in
memory. For example, the access size of `ld.v4.b32` is 16 bytes, while the access size of
`atom.f16x2` is 4 bytes.

### 5.4.6. [Parameterized Variable Names](#parameterized-variable-names)[](#parameterized-variable-names "Permalink to this headline")

Since PTX supports virtual registers, it is quite common for a compiler frontend to generate a large
number of register names. Rather than require explicit declaration of every name, PTX supports a
syntax for creating a set of variables having a common prefix string appended with integer suffixes.

For example, suppose a program uses a large number, say one hundred, of `.b32` variables, named
`%r0`, `%r1`, …, `%r99`. These 100 register variables can be declared as follows:

```
.reg .b32 %r<100>;    // declare %r0, %r1, ..., %r99
```

This shorthand syntax may be used with any of the fundamental types and with any state space, and
may be preceded by an alignment specifier. Array variables cannot be declared this way, nor are
initializers permitted.

### 5.4.7. [Variable Attributes](#variable-attributes)[](#variable-attributes "Permalink to this headline")

Variables may be declared with an optional `.attribute` directive which allows specifying special
attributes of variables. Keyword `.attribute` is followed by attribute specification inside
parenthesis. Multiple attributes are separated by comma.

[Variable and Function Attribute Directive: .attribute](#variable-and-function-attribute-directive-attribute) describes the `.attribute`
directive.

### 5.4.8. [Variable and Function Attribute Directive: `.attribute`](#variable-and-function-attribute-directive-attribute)[](#variable-and-function-attribute-directive-attribute "Permalink to this headline")

`.attribute`

Variable and function attributes

Description

Used to specify special attributes of a variable or a function.

The following attributes are supported.

`.managed`
:   `.managed` attribute specifies that variable will be allocated at a location in unified virtual
    memory environment where host and other devices in the system can reference the variable
    directly. This attribute can only be used with variables in .global state space. See the *CUDA
    UVM-Lite Programming Guide* for details.

`.unified`
:   `.unified` attribute specifies that function has the same memory address on the host and on
    other devices in the system. Integer constants `uuid1` and `uuid2` respectively specify upper
    and lower 64 bits of the unique identifier associated with the function or the variable. This
    attribute can only be used on device functions or on variables in the `.global` state
    space. Variables with `.unified` attribute are read-only and must be loaded by specifying
    `.unified` qualifier on the address operand of `ld` instruction, otherwise the behavior is
    undefined.

PTX ISA Notes

* Introduced in PTX ISA version 4.0.
* Support for function attributes introduced in PTX ISA version 8.0.

Target ISA Notes

* `.managed` attribute requires `sm_30` or higher.
* `.unified` attribute requires `sm_90` or higher.

Examples

```
.global .attribute(.managed) .s32 g;

.global .attribute(.managed) .u64 x;



.global .attribute(.unified(19,95)) .f32 f;



.func .attribute(.unified(0xAB, 0xCD)) bar() { ... }
```